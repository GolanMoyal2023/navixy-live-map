<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Navixy Live Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <!-- Marker Clustering for large scale (800+ markers) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .view-tabs {
        position: absolute;
        top: 72px;
        right: 12px;
        z-index: 1000;
        display: flex;
        gap: 6px;
      }

      .view-tab {
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 12px;
      }

      .view-tab.active {
        background: #2563eb;
        border-color: #1d4ed8;
      }

      .data-source-toggle {
        position: absolute;
        top: 72px;
        left: 12px;
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: 6px;
        background: rgba(17, 24, 39, 0.85);
        padding: 4px 8px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      .data-source-actions {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-left: 4px;
      }

      .source-label {
        color: #9ca3af;
        font-size: 11px;
      }

      .source-btn {
        background: transparent;
        color: #9ca3af;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 2px 8px;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.2s;
      }

      .source-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #ffffff;
      }

      .source-btn.active {
        background: #059669;
        border-color: #047857;
        color: #ffffff;
      }
      .source-action-btn {
        background: #2563eb;
        color: #ffffff;
        border: 1px solid #1d4ed8;
        border-radius: 4px;
        padding: 2px 8px;
        cursor: pointer;
        font-size: 11px;
      }
      .source-action-btn:hover { background: #1d4ed8; }
      .source-action-btn:disabled {
        opacity: 0.6;
        cursor: wait;
      }

      /* Beacon cluster styling */
      .beacon-cluster {
        background: transparent !important;
      }
      
      .marker-cluster {
        background: rgba(147, 51, 234, 0.4) !important;
      }
      
      .marker-cluster div {
        background: #9333ea !important;
      }

      .view-panel {
        display: none;
        height: 100%;
        width: 100%;
        position: relative;
      }

      .view-panel.active {
        display: block;
      }

      .table-view {
        height: 100%;
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        box-sizing: border-box;
      }

      .table-container {
        max-height: calc(100% - 16px);
        overflow: auto;
        border: 1px solid #1f2937;
        border-radius: 8px;
      }

      table.gse-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      table.gse-table th,
      table.gse-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #1f2937;
        text-align: left;
        vertical-align: top;
      }

      table.gse-table td.gse-table-key {
        font-weight: 700;
        color: #e2e8f0;
        white-space: nowrap;
      }

      table.gse-table th {
        position: sticky;
        top: 0;
        background: #111827;
        z-index: 1;
      }

      table.gse-table tr.section-row th {
        background: #0b1220;
        font-weight: 700;
        text-align: left;
        font-size: 12px;
      }

      .gse-field-label {
        font-weight: 600;
        color: inherit;
      }

      .gse-ts {
        font-size: 70%;
        color: #cbd5f5;
        margin-left: 6px;
      }

      @media (max-width: 480px) {
        .gse-ts {
          display: block;
          margin-left: 0;
        }
      }

      .gse-popup {
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 11px;
        line-height: 1.25;
        max-width: 260px;
        max-height: 65vh;
        overflow: auto;
        color: #0f172a;
      }

      .gse-popup h4 {
        margin: 0 0 6px;
        font-size: 12px;
      }

      .gse-section {
        margin: 10px 0 6px;
        font-weight: 700;
        color: #0b4a6f;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 2px;
      }

      .gse-row {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        margin: 3px 0 4px;
        padding: 4px 6px;
        border-radius: 6px;
      }

      .gse-label {
        font-weight: 600;
        white-space: nowrap;
      }

      .gse-value {
        text-align: right;
        overflow-wrap: anywhere;
      }

      .gse-style-soft .gse-row {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
      }

      .gse-style-soft .gse-label {
        color: #1e3a8a;
      }

      .gse-style-soft .gse-value {
        color: #0f172a;
      }

      .gse-style-outline .gse-row {
        background: #ffffff;
        border: 1px solid #cbd5f5;
      }

      .gse-style-outline .gse-label {
        color: #0f766e;
      }

      .gse-style-outline .gse-value {
        color: #0f172a;
      }

      .gse-style-compact .gse-row {
        background: transparent;
        border: none;
        border-bottom: 1px dashed #e2e8f0;
        border-radius: 0;
        padding: 3px 0;
      }

      .gse-style-compact .gse-label {
        color: #334155;
      }

      .gse-style-compact .gse-value {
        color: #0f172a;
      }

      .map-overlay {
        position: absolute;
        top: 12px;
        left: 56px;
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 12px;
        z-index: 1000;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #clearPopup {
        background: #1f2937;
        border: 1px solid #374151;
        color: #ffffff;
        padding: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }

      .map-overlay.debug {
        top: 48px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .map-overlay.legend {
        top: auto;
        bottom: 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .legend-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.4);
      }

      .hidden {
        display: none;
      }

      .llbg-label {
        background: rgba(255, 255, 255, 0.9);
        color: #4c1d95;
        border: 1px solid #c4b5fd;
        border-radius: 4px;
        padding: 1px 4px;
        font-size: 10px;
      }

      .leaflet-tooltip.gse-label {
        border-radius: 6px;
        color: #ffffff !important;
        font-weight: 700;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(0, 0, 0, 0.25) !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
      }
      .leaflet-tooltip.gse-status-available,
      .legend-swatch.gse-status-available { background: #00a651 !important; }
      .leaflet-tooltip.gse-status-in-use,
      .legend-swatch.gse-status-in-use { background: #f97316 !important; }
      .leaflet-tooltip.gse-status-moving,
      .legend-swatch.gse-status-moving { background: #1e88e5 !important; }
      .leaflet-tooltip.gse-status-idle,
      .legend-swatch.gse-status-idle { background: #e91e63 !important; }
      .leaflet-tooltip.gse-status-ignition,
      .legend-swatch.gse-status-ignition { background: #fdd835 !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-working,
      .legend-swatch.gse-status-working { background: #e53935 !important; }
      .leaflet-tooltip.gse-status-maintenance,
      .legend-swatch.gse-status-maintenance { background: #fb8c00 !important; }
      .leaflet-tooltip.gse-status-low-battery,
      .legend-swatch.gse-status-low-battery { background: #fbc02d !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-alert,
      .legend-swatch.gse-status-alert { background: #ef6c00 !important; }

      /* ===== BEACON / EYEBECON STYLES ===== */
      .beacon-marker {
        border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.9);
        box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: bold;
        color: white;
      }
      .beacon-category-towed { background: #9333ea !important; } /* Purple */
      .beacon-category-container { background: #2563eb !important; } /* Blue */
      .beacon-category-equipment { background: #059669 !important; } /* Green */
      .beacon-category-personnel { background: #dc2626 !important; } /* Red */
      .beacon-category-vehicle { background: #ea580c !important; } /* Orange */
      .beacon-category-eye_beacon { background: #9333ea !important; } /* Purple - Eye Beacon */
      .beacon-category-eye_sensor { background: #2563eb !important; } /* Blue - Eye Sensor */
      .beacon-category-default { background: #6b7280 !important; } /* Gray */

      .leaflet-tooltip.beacon-label {
        border-radius: 4px;
        color: #ffffff !important;
        font-weight: 600;
        font-size: 10px;
        padding: 2px 5px;
        border: 1px solid rgba(0, 0, 0, 0.3) !important;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }
      .leaflet-tooltip.beacon-category-towed { background: #9333ea !important; }
      .leaflet-tooltip.beacon-category-container { background: #2563eb !important; }
      .leaflet-tooltip.beacon-category-equipment { background: #059669 !important; }
      .leaflet-tooltip.beacon-category-personnel { background: #dc2626 !important; }
      .leaflet-tooltip.beacon-category-vehicle { background: #ea580c !important; }
      .leaflet-tooltip.beacon-category-eye_beacon { background: #9333ea !important; }
      .leaflet-tooltip.beacon-category-eye_sensor { background: #2563eb !important; }
      .leaflet-tooltip.beacon-category-default { background: #6b7280 !important; }

      .beacon-popup {
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 11px;
        line-height: 1.4;
        min-width: 180px;
      }
      .beacon-popup h4 {
        margin: 0 0 8px;
        padding-bottom: 4px;
        border-bottom: 2px solid;
        font-size: 13px;
      }
      .beacon-popup h4.beacon-category-towed { border-color: #9333ea; color: #9333ea; }
      .beacon-popup h4.beacon-category-container { border-color: #2563eb; color: #2563eb; }
      .beacon-popup h4.beacon-category-equipment { border-color: #059669; color: #059669; }
      .beacon-popup h4.beacon-category-personnel { border-color: #dc2626; color: #dc2626; }
      .beacon-popup h4.beacon-category-vehicle { border-color: #ea580c; color: #ea580c; }
      .beacon-popup h4.beacon-category-eye_beacon { border-color: #9333ea; color: #9333ea; }
      .beacon-popup h4.beacon-category-eye_sensor { border-color: #2563eb; color: #2563eb; }
      .beacon-popup h4.beacon-category-default { border-color: #6b7280; color: #6b7280; }
      .beacon-popup .beacon-row {
        display: flex;
        justify-content: space-between;
        padding: 2px 0;
      }
      .beacon-popup .beacon-row-label {
        color: #64748b;
        font-weight: 500;
      }
      .beacon-popup .beacon-row-value {
        color: #0f172a;
        font-weight: 600;
      }
      .beacon-popup .beacon-host {
        margin-top: 8px;
        padding-top: 6px;
        border-top: 1px dashed #cbd5e1;
        font-size: 10px;
        color: #64748b;
      }

      .map-overlay.beacon-legend {
        top: auto;
        bottom: 12px;
        left: 180px;
        background: rgba(148, 163, 184, 0.8);
        color: #0f172a;
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
        font-size: 11px;
      }
      .map-overlay.beacon-legend .legend-title {
        font-weight: 700;
        font-size: 12px;
        margin-bottom: 2px;
      }
      .beacon-legend-toggle { margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(0,0,0,0.1); }
      .beacon-legend-label { display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 11px; -webkit-user-select: none; user-select: none; }
      .beacon-legend-label input[type="checkbox"] { cursor: pointer; }
      .options-box {
        top: 10px;
        right: 10px;
        left: auto;
        padding: 8px 12px;
        min-width: 220px;
        z-index: 1000;
      }
      .options-box .legend-title { margin-bottom: 6px; font-size: 11px; }
      .options-actions {
        margin-top: 8px;
        padding-top: 6px;
        border-top: 1px solid rgba(0,0,0,0.1);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .options-action-btn {
        background: #2563eb;
        color: #fff;
        border: 1px solid #1d4ed8;
        border-radius: 4px;
        padding: 4px 10px;
        font-size: 11px;
        cursor: pointer;
      }
      .options-action-btn:hover { background: #1d4ed8; }
      .options-action-btn:disabled {
        opacity: 0.6;
        cursor: wait;
      }
      .options-action-status {
        font-size: 10px;
        color: #334155;
      }
      .beacon-legend-row {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .beacon-legend-swatch {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid white;
        box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      }
      .beacon-host-badge {
        background: rgba(37, 99, 235, 0.95);
        color: #fff;
        border: 1px solid rgba(255,255,255,0.9);
        border-radius: 10px;
        min-width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 11px;
        font-weight: 700;
        box-shadow: 0 1px 3px rgba(0,0,0,0.35);
        padding: 0 4px;
      }
    </style>
  </head>
  <body>
    <div class="view-tabs">
      <button class="view-tab active" data-view="map">Map</button>
      <button class="view-tab" data-view="table">Table</button>
    </div>
    <div class="data-source-toggle">
      <span class="source-label">Data:</span>
      <button class="source-btn" data-source="motorized_gse" onclick="switchDataSource('motorized_gse')">Motorized GSE</button>
      <button class="source-btn" data-source="direct" onclick="switchDataSource('direct')">Direct</button>
      <button class="source-btn active" data-source="both" onclick="switchDataSource('both')">Both</button>
      <div class="data-source-actions">
        <button id="relinkBtnTop" type="button" class="source-action-btn" title="Force beacon re-link to nearest active tracker">Re-link</button>
      </div>
    </div>
    <div id="mapView" class="view-panel active">
      <div id="map"></div>
      <div id="optionsBox" class="map-overlay options-box beacon-legend">
        <div class="legend-title">Options</div>
        <label class="beacon-legend-label" title="Show or hide X-GPS (Human Agent) tracker on map">
          <input type="checkbox" id="toggleXGpsOptions" checked aria-label="X-GPS Object (Human Agent tracker)">
          <span style="color:#0ea5e9;font-size:14px">üìç</span> X-GPS Object (Human Agent tracker)
        </label>
        <div class="options-actions">
          <button id="relinkBtn" type="button" class="options-action-btn" title="Force beacon re-link to live detecting tracker">Re-link</button>
          <span id="relinkStatus" class="options-action-status"></span>
        </div>
      </div>
      <div class="map-overlay">
        <span id="mapStatus">Loading...</span>
        <button id="clearPopup" type="button">Clear</button>
      </div>
      <div id="brokerWarning" class="map-overlay broker-warning hidden" style="background:rgba(220,38,38,0.9);color:#fff;padding:8px 12px;font-weight:bold;top:50px;left:50%;transform:translateX(-50%);border-radius:6px;z-index:2000;">
        No beacon data without broker. Run .\start_all.ps1
      </div>
      <div id="debugOverlay" class="map-overlay debug hidden">
        <span id="mapDebug">debug</span>
      </div>
      <div id="legendOverlay" class="map-overlay legend hidden">
        <div class="legend-row"><span class="legend-swatch gse-status-available"></span>Available</div>
        <div class="legend-row"><span class="legend-swatch gse-status-in-use"></span>In use</div>
        <div class="legend-row"><span class="legend-swatch gse-status-moving"></span>Moving</div>
        <div class="legend-row"><span class="legend-swatch gse-status-idle"></span>Idle</div>
        <div class="legend-row"><span class="legend-swatch gse-status-ignition"></span>Ignition on</div>
        <div class="legend-row"><span class="legend-swatch gse-status-working"></span>Working</div>
        <div class="legend-row"><span class="legend-swatch gse-status-maintenance"></span>Maintenance</div>
        <div class="legend-row"><span class="legend-swatch gse-status-low-battery"></span>Low battery</div>
        <div class="legend-row"><span class="legend-swatch gse-status-alert"></span>Alert</div>
      </div>
      <div id="beaconLegend" class="map-overlay beacon-legend">
        <div class="legend-title">üì° Eye Beacon Categories</div>
        <div class="beacon-legend-row"><span style="color:#9333ea;font-size:14px">‚óÜ</span> Towed Device</div>
        <div class="beacon-legend-row"><span style="color:#2563eb;font-size:14px">‚ñ†</span> Equipment</div>
        <div class="beacon-legend-row"><span style="color:#ea580c;font-size:14px">‚òÖ</span> Safety</div>
        <div class="beacon-legend-row"><span style="color:#ea580c;font-size:14px">‚óè</span> Container</div>
        <div class="beacon-legend-row"><span style="color:#dc2626;font-size:14px">‚òÖ</span> Personnel</div>
        <div class="beacon-legend-row"><span style="color:#7c3aed;font-size:14px">‚¨°</span> Vehicle</div>
        <div class="beacon-legend-row beacon-legend-toggle">
          <label class="beacon-legend-label">
            <input type="checkbox" id="toggleXGps" checked>
            <span style="color:#0ea5e9;font-size:14px">üìç</span> X-GPS Object (Human Agent tracker)
          </label>
        </div>
      </div>
    </div>
    <div id="tableView" class="view-panel table-view">
      <div class="table-container">
        <table class="gse-table">
          <thead id="gseTableHead"></thead>
          <tbody id="gseTableBody"></tbody>
        </table>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <!-- Marker Clustering for large scale -->
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <!-- Optional: load config.js to set window.NAVIXY_MAP_API_BASE for production (GitHub Pages) -->
    <script src="config.js"></script>
    <!-- Local (127.0.0.1) when opened from server PC; public URL when from GitHub Pages (e.g. mobile). -->
    <script>
      (function(){
        var host = (typeof location !== "undefined" && location.hostname) ? location.hostname : "";
        var isLocal = host === "127.0.0.1" || host === "localhost";
        var base;
        if (isLocal) {
          base = (window.NAVIXY_MAP_API_BASE) ? String(window.NAVIXY_MAP_API_BASE).replace(/:8765\/?$|:8767\/?$|:8768\/?$|\/data\/?$/, "") : "http://127.0.0.1";
          if (String(window.NAVIXY_MAP_API_BASE || "").indexOf("8765") !== -1) base = base.replace(/\/?$/, "") + ":8765";
        } else {
          base = (window.NAVIXY_MAP_API_BASE_PUBLIC) ? String(window.NAVIXY_MAP_API_BASE_PUBLIC).replace(/:8765\/?$|:8767\/?$|:8768\/?$|\/data\/?$/, "") : (window.NAVIXY_MAP_API_BASE ? String(window.NAVIXY_MAP_API_BASE).replace(/:8765\/?$|:8767\/?$|:8768\/?$|\/data\/?$/, "") : "");
        }
        window.__NAVIXY_API_BASE = base;
      })();
    </script>
    <script>
      (function(){
        var base = window.__NAVIXY_API_BASE || "http://127.0.0.1";
        var useSingleData = base.indexOf("https://") === 0 || (base.indexOf("http://") === 0 && base.indexOf("127.0.0.1") === -1) || base.indexOf("8765") !== -1;
        if (window.NAVIXY_MAP_DATA_SOURCES) {
          window.__NAVIXY_DATA_SOURCES = window.NAVIXY_MAP_DATA_SOURCES;
        } else if (useSingleData) {
          var dataUrl = base.replace(/\/?$/, "") + "/data";
          window.__NAVIXY_DATA_SOURCES = { motorized_gse: dataUrl, direct: dataUrl, both: null };
        } else {
          window.__NAVIXY_DATA_SOURCES = { motorized_gse: base + ":8767/data", direct: base + ":8768/data", both: null };
        }
      })();
      const DATA_SOURCES = window.__NAVIXY_DATA_SOURCES;
      // No synthetic home fallback positions - render only tracker-linked beacon positions.
      const DIRECT_BEACON_POSITIONS_FALLBACK = {};
      let currentDataSource = "both";
      let LIVE_API_URL = DATA_SOURCES[currentDataSource];
      let showXGpsMarkers = true;
      
      const POPUP_STYLE = "outline"; // soft | outline | compact
      const POLL_INTERVAL_MS = 5000; // 5s ‚Äì avoid constant "Loading‚Ä¶" and reduce server load
      
      function switchDataSource(source) {
        currentDataSource = source;
        LIVE_API_URL = DATA_SOURCES[source];
        console.log(`Switched to ${source}`);
        
        document.querySelectorAll('.source-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.source === source);
        });
        layer.clearLayers();
        beaconLayer.clearLayers();
        beaconLinkLayer.clearLayers();
        beaconBadgeLayer.clearLayers();
        Object.keys(markers).forEach(k => { delete markers[k]; });
        Object.keys(beaconMarkers).forEach(k => delete beaconMarkers[k]);
        lastBeaconPayload = {};
        lastBeaconTrackerRows = [];
        if (source === "direct") Object.keys(blePositions).forEach(k => { delete blePositions[k]; });
        xGpsLayer.clearLayers();
        Object.keys(markersXgps).forEach(k => { delete markersXgps[k]; });
        hasLoadedOnce = false;
        loadData();
      }

      const map = L.map("map").setView([32.004, 34.876], 13);
      const layer = L.layerGroup().addTo(map);
      const xGpsLayer = L.layerGroup().addTo(map); // X-GPS (Human tracker) ‚Äì show/hide via Options or layer control
      const llbgLayer = L.layerGroup();
      const debugLayer = L.layerGroup();
      const legendLayer = L.layerGroup();
      const beaconLayer = L.layerGroup().addTo(map);
      const beaconLinkLayer = L.layerGroup().addTo(map);
      const beaconBadgeLayer = L.layerGroup().addTo(map);
      const chartLayers = {};
      const beaconMarkers = {};
      const markersXgps = {}; // X-GPS markers (Golan-X-GPS / SKODA) ‚Äì separate layer so layer control can hide them
      let lastBeaconPayload = {};
      let lastBeaconTrackerRows = [];
      const BEACON_EXPAND_ZOOM = 16;

      // ===== BEACON CATEGORY CONFIGURATION =====
      // Categories based on MAC prefix or user-defined mapping
      const BEACON_CATEGORIES = {
        "towed": { color: "#9333ea", label: "Towed Device", icon: "‚óÜ" },
        "container": { color: "#2563eb", label: "Container", icon: "‚ñ†" },
        "equipment": { color: "#059669", label: "Equipment", icon: "‚óè" },
        "personnel": { color: "#dc2626", label: "Personnel", icon: "‚ñ≤" },
        "vehicle": { color: "#ea580c", label: "Vehicle", icon: "‚òÖ" },
        "eye_beacon": { color: "#9333ea", label: "Eye Beacon", icon: "‚óè" },
        "eye_sensor": { color: "#2563eb", label: "Eye Sensor", icon: "‚óÜ" },
        "default": { color: "#6b7280", label: "Other", icon: "‚óè" }
      };

      // Known Teltonika Eye Beacons/Sensors (matches BLE_Definitions + seed_beacon_data.sql)
      const KNOWN_BEACONS = {
        "7CD9F407F95C": { name: "Eybe2plus1", sn: "6204011070", type: "eye_beacon", category: "Towed Device" },
        "7CD9F4003536": { name: "Eybe2plus2", sn: "6204011168", type: "eye_beacon", category: "Equipment" },
        "7CD9F406427B": { name: "EyeBe3", sn: "", type: "eye_beacon", category: "Equipment" },
        "7CD9F407A2DB": { name: "EyeBe4", sn: "", type: "eye_beacon", category: "Equipment" },
        "7CD9F4116EE7": { name: "Eysen2plus", sn: "6134010143", type: "eye_sensor", category: "Safety" },
        "7CD9F4106A58": { name: "Beacon 6A58", sn: "", type: "eye_beacon", category: "Uncategorized" },
        "7cd9f407f95c": { name: "Eybe2plus1", sn: "6204011070", type: "eye_beacon", category: "Towed Device" },
        "7cd9f4003536": { name: "Eybe2plus2", sn: "6204011168", type: "eye_beacon", category: "Equipment" },
        "7cd9f406427b": { name: "EyeBe3", sn: "", type: "eye_beacon", category: "Equipment" },
        "7cd9f407a2db": { name: "EyeBe4", sn: "", type: "eye_beacon", category: "Equipment" },
        "7cd9f4116ee7": { name: "Eysen2plus", sn: "6134010143", type: "eye_sensor", category: "Safety" },
        "7cd9f4106a58": { name: "Beacon 6A58", sn: "", type: "eye_beacon", category: "Uncategorized" },
      };

      // Category icons and colors (matches seed legend: ‚óÜ Towed, ‚ñ†‚ñ≤‚óè Equipment, ‚òÖ Safety)
      const CATEGORY_CONFIG = {
        "Towed Device": { shape: "diamond", color: "#9333ea", image: "Pictures/TowBar.png" },   // ‚óÜ Purple
        "Equipment": { shape: "square", color: "#2563eb", image: null },                        // ‚ñ† Blue
        "Safety": { shape: "star", color: "#ea580c", image: null },                             // ‚òÖ Orange
        "Container": { shape: "circle", color: "#ea580c", image: null },
        "Personnel": { shape: "star", color: "#dc2626", image: null },
        "Vehicle": { shape: "hexagon", color: "#7c3aed", image: null },
        "Uncategorized": { shape: "circle", color: "#6b7280", image: null },
      };
      const BLE_ALLOWED_TRACKER_TOKENS = ["skoda", "5032", "6074"];
      // Fixed business mapping requested by operations:
      // 4 beacons travel together with SKODA, one beacon stays with GSE 5032.
      const FORCED_BEACON_HOST_BY_MAC = {
        "7cd9f407f95c": "SKODA",
        "7cd9f407a2db": "SKODA",
        "7cd9f4116ee7": "SKODA",
        "7cd9f4106a58": "SKODA",
        "7cd9f4003536": "5032",
      };
      const STRICT_BEACON_MACS = new Set(Object.keys(FORCED_BEACON_HOST_BY_MAC));
      const BEACON_SHAPE_BY_MAC = {
        "7cd9f407f95c": "square",
        "7cd9f407a2db": "triangle",
        "7cd9f4116ee7": "hexagon",
        "7cd9f4106a58": "pentagon",
        "7cd9f4003536": "circle",
      };

      // Extract beacons from tracker data
      function extractBeaconsFromTrackers(rows) {
        const beacons = [];
        rows.forEach(row => {
          if (row.beacons && Array.isArray(row.beacons)) {
            row.beacons.forEach(beacon => {
              if (beacon.mac) {
                const knownInfo = KNOWN_BEACONS[beacon.mac.toUpperCase()] || {};
                beacons.push({
                  id: beacon.mac,
                  mac: beacon.mac,
                  name: knownInfo.name || `Beacon ${beacon.mac.slice(-4)}`,
                  sn: knownInfo.sn,
                  beaconType: knownInfo.type || "default",
                  category: knownInfo.category || "Uncategorized",
                  battery: beacon.battery,
                  magnetSensors: beacon.magnet_sensors || {},
                  lastSeen: beacon.last_seen,
                  hostTrackerId: row.tracker_id,
                  hostTrackerLabel: row.label,
                  lat: row.lat,
                  lng: row.lng,
                });
              }
            });
          }
        });
        return beacons;
      }

      function beaconCategoryClass(category) {
        return BEACON_CATEGORIES[category] ? `beacon-category-${category}` : "beacon-category-default";
      }

      // SVG shape generators for small beacon icons
      function getShapeSVG(shape, color, size) {
        const s = size;
        const half = s / 2;
        const stroke = "white";
        const strokeWidth = 2;
        
        switch (shape) {
          case "diamond":
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <polygon points="${half},2 ${s-2},${half} ${half},${s-2} 2,${half}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
          case "square":
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <rect x="3" y="3" width="${s-6}" height="${s-6}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
          case "triangle":
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <polygon points="${half},3 ${s-3},${s-3} 3,${s-3}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
          case "circle":
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <circle cx="${half}" cy="${half}" r="${half-3}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
          case "star":
            const outerR = half - 2;
            const innerR = outerR * 0.4;
            let starPoints = "";
            for (let i = 0; i < 5; i++) {
              const outerAngle = (Math.PI / 2) + (i * 2 * Math.PI / 5);
              const innerAngle = outerAngle + Math.PI / 5;
              starPoints += `${half + outerR * Math.cos(outerAngle)},${half - outerR * Math.sin(outerAngle)} `;
              starPoints += `${half + innerR * Math.cos(innerAngle)},${half - innerR * Math.sin(innerAngle)} `;
            }
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <polygon points="${starPoints.trim()}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
          case "hexagon":
            let hexPoints = "";
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 6) + (i * Math.PI / 3);
              hexPoints += `${half + (half-3) * Math.cos(angle)},${half - (half-3) * Math.sin(angle)} `;
            }
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <polygon points="${hexPoints.trim()}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
          case "pentagon":
            let pentPoints = "";
            for (let i = 0; i < 5; i++) {
              const angle = (Math.PI / 2) + (i * 2 * Math.PI / 5);
              pentPoints += `${half + (half-3) * Math.cos(angle)},${half - (half-3) * Math.sin(angle)} `;
            }
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <polygon points="${pentPoints.trim()}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
          default:
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
              <circle cx="${half}" cy="${half}" r="${half-3}" fill="${color}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
            </svg>`;
        }
      }
      
      function beaconShapeForMac(mac, fallbackCategory) {
        const byMac = BEACON_SHAPE_BY_MAC[String(mac || "").toLowerCase()];
        if (byMac) return byMac;
        const catConfig = CATEGORY_CONFIG[fallbackCategory] || CATEGORY_CONFIG["Uncategorized"];
        return catConfig.shape || "circle";
      }

      function createBeaconIcon(beaconType, assetCategory, size = 24, mac = "") {
        const catConfig = CATEGORY_CONFIG[assetCategory] || CATEGORY_CONFIG["Uncategorized"];
        const shape = beaconShapeForMac(mac, assetCategory);
        const shapeSVG = getShapeSVG(shape, catConfig.color, size);
        
        return L.divIcon({
          className: `beacon-marker`,
          html: `<div style="filter:drop-shadow(0 2px 3px rgba(0,0,0,0.4));cursor:pointer;">${shapeSVG}</div>`,
          iconSize: [size, size],
          iconAnchor: [size / 2, size / 2],
          popupAnchor: [0, -size / 2],
        });
      }

      function formatLastSaw(isoOrDate) {
        if (!isoOrDate) return "";
        const s = String(isoOrDate);
        if (s.indexOf("T") !== -1) return s.replace("T", " ").substring(0, 19);
        return s.substring(0, 19);
      }

      function beaconPopupHtml(beacon) {
        const typeInfo = BEACON_CATEGORIES[beacon.beaconType] || BEACON_CATEGORIES["default"];
        const catConfig = CATEGORY_CONFIG[beacon.category] || CATEGORY_CONFIG["Uncategorized"];
        
        // Battery: from broker (Teltonika) can be volts (2.0‚Äì3.0) or percent (0‚Äì100)
        const rawBattery = beacon.battery != null && beacon.battery !== "" ? parseFloat(beacon.battery) : NaN;
        const isVolts = Number.isFinite(rawBattery) && rawBattery >= 1.5 && rawBattery <= 4;
        const batteryPercent = Number.isFinite(rawBattery)
          ? (isVolts ? Math.max(0, Math.min(100, ((rawBattery - 2.0) / 1.0) * 100)) : Math.max(0, Math.min(100, rawBattery)))
          : 0;
        const hasBattery = Number.isFinite(rawBattery) && (isVolts ? rawBattery > 0 : rawBattery >= 0);
        const batteryColor = !hasBattery ? "#6b7280" : batteryPercent > 50 ? "#059669" : batteryPercent > 20 ? "#ea580c" : "#dc2626";
        const batteryDisplay = hasBattery
          ? (isVolts ? `${rawBattery.toFixed(2)}V (${batteryPercent.toFixed(0)}%)` : `${batteryPercent.toFixed(0)}%`)
          : "N/A (not reported)";
        
        // Magnet sensor status - show for all beacons that have data
        let magnetStatus = "";
        if (beacon.magnetSensors && Object.keys(beacon.magnetSensors).length > 0) {
          const magnetValues = Object.entries(beacon.magnetSensors)
            .map(([k, v]) => {
              const num = k.replace("magnet_", "");
              const status = v === "1" ? "üî¥ DETECTED" : "‚ö™ Clear";
              return `M${num}: ${status}`;
            })
            .join(" | ");
          magnetStatus = `<div class="beacon-row">
              <span class="beacon-row-label">Magnet Sensors</span>
              <span class="beacon-row-value" style="font-size:11px">${magnetValues}</span>
            </div>`;
        }

        // Format coordinates
        const latStr = beacon.lat ? Number(beacon.lat).toFixed(6) : "N/A";
        const lngStr = beacon.lng ? Number(beacon.lng).toFixed(6) : "N/A";
        
        // Create header icon - use real image if available, otherwise shape symbol
        let headerIcon;
        if (catConfig.image) {
          headerIcon = `<img src="${catConfig.image}" style="width:48px;height:32px;object-fit:contain;background:white;border-radius:4px;padding:2px;" />`;
        } else {
          const mappedShape = beaconShapeForMac(beacon.mac, beacon.category);
          const shapeSymbols = {
            diamond: "‚óÜ", square: "‚ñ†", triangle: "‚ñ≤", 
            circle: "‚óè", star: "‚òÖ", hexagon: "‚¨°", pentagon: "‚¨ü"
          };
          const headerSymbol = shapeSymbols[mappedShape] || "‚óè";
          headerIcon = `<span style="font-size:24px;color:white;text-shadow:0 1px 2px rgba(0,0,0,0.3)">${headerSymbol}</span>`;
        }
        
        const popupLastSeen = formatLastSaw(beacon.lastSeen || beacon.lastSeenAt || beacon.lastUpdate) || "N/A";
        const popupRssi = beacon.rssi != null && Number.isFinite(Number(beacon.rssi)) ? `${Math.round(Number(beacon.rssi))} dBm` : "N/A";
        const pairingSeconds = Math.max(0, Math.floor(Number(beacon.pairingDuration || 0)));
        return `
          <div class="beacon-popup">
            <div class="beacon-header" style="background:${catConfig.color};color:white;padding:8px 12px;margin:-12px -12px 10px -12px;border-radius:4px 4px 0 0;display:flex;align-items:center;gap:8px;">
              ${headerIcon}
              <div>
                <div style="font-weight:700;font-size:13px">${beacon.category}</div>
                <div style="font-size:11px;opacity:0.9">${beacon.name}</div>
              </div>
            </div>
            <div class="beacon-row" style="font-weight:700;color:#334155;">Stationery Device Information</div>
            <div class="beacon-row">
              <span class="beacon-row-label">Category</span>
              <span class="beacon-row-value">${beacon.category}</span>
            </div>
            <div class="beacon-row">
              <span class="beacon-row-label">Stationery Name</span>
              <span class="beacon-row-value">${beacon.name}</span>
            </div>
            <div class="beacon-row" style="font-weight:700;color:#334155;margin-top:6px;">HW</div>
            <div class="beacon-row">
              <span class="beacon-row-label">Type</span>
              <span class="beacon-row-value">${typeInfo.label}</span>
            </div>
            <div class="beacon-row">
              <span class="beacon-row-label">MAC</span>
              <span class="beacon-row-value" style="font-family:monospace">${beacon.mac}</span>
            </div>
            ${beacon.sn ? `<div class="beacon-row">
              <span class="beacon-row-label">S/N</span>
              <span class="beacon-row-value">${beacon.sn}</span>
            </div>` : ""}
            <div class="beacon-row">
              <span class="beacon-row-label">Battery</span>
              <span class="beacon-row-value" style="color:${batteryColor}">${batteryDisplay}</span>
            </div>
            ${magnetStatus}
            <div class="beacon-row">
              <span class="beacon-row-label">Lat / Long</span>
              <span class="beacon-row-value" style="font-family:monospace;font-size:10px">${latStr}, ${lngStr}</span>
            </div>
            ${beacon.rssi != null ? `<div class="beacon-row">
              <span class="beacon-row-label">Signal (RSSI)</span>
              <span class="beacon-row-value" style="font-family:monospace">${Math.round(beacon.rssi)} dBm</span>
            </div>` : ""}
            ${beacon.estimatedDistance != null ? `<div class="beacon-row">
              <span class="beacon-row-label">~Distance</span>
              <span class="beacon-row-value">~${beacon.estimatedDistance.toFixed(1)} m from ${beacon.hostTrackerLabel}</span>
            </div>` : ""}
            <div class="beacon-row">
              <span class="beacon-row-label">Last Seen</span>
              <span class="beacon-row-value">${popupLastSeen}</span>
            </div>
            <div class="beacon-host" style="background:#f3f4f6;padding:6px 8px;border-radius:4px;margin-top:8px;">
              <div style="font-weight:600;margin-bottom:4px;">üìç BLE Position Info</div>
              <div>Last set by: <strong>${beacon.lastSeenByTracker || beacon.hostTrackerLabel}</strong></div>
              <div>Last seen: <strong>${popupLastSeen}</strong></div>
              <div>Battery: <strong style="color:${batteryColor}">${batteryDisplay}</strong></div>
              <div>RSSI: <strong>${popupRssi}</strong></div>
              <div>Last Location: <strong>${latStr}, ${lngStr}</strong></div>
              ${beacon.isPaired ?
                `<div style="color:#059669;font-weight:600;">üîó PAIRED (${pairingSeconds}s) - Following tracker</div>` :
                beacon.pairingDuration > 0 ?
                `<div style="color:#f59e0b;font-weight:600;">‚è≥ Pairing... (${pairingSeconds}s / 60s)</div>` :
                `<div style="color:#6b7280;">üìç Last known position</div>`
              }
              ${beacon.estimatedDistance != null
                ? `<div>üì° RSSI distance: <strong>~${beacon.estimatedDistance.toFixed(1)} m</strong> from ${beacon.hostTrackerLabel}</div>`
                : (beacon.distanceFromTracker > 0
                  ? `<div>üìè Distance to tracker: <strong>${Math.round(beacon.distanceFromTracker)} m</strong></div>`
                  : '')}
            </div>
          </div>
        `;
      }

      // ============================================================
      // BLE LOCATION LOGIC:
      // - BLE beacons are on STATIC equipment (tow bars, etc.)
      // - Trackers are on MOTORIZED vehicles (tractors)
      // - Only update BLE location if tracker detects it for > 60 sec (being towed)
      // - Brief pass-by detection should NOT change BLE location
      // ============================================================
      
      // Permanent storage for BLE positions (survives page refresh if we add localStorage)
      const blePositions = {};  // { mac: { lat, lng, lastTracker, lastTrackerLabel, lastUpdate, distance, pairingStart } }
      const blePairingTracker = {};  // { mac: trackerId } - which tracker is currently paired
      const blePairingStart = {};  // { mac: timestamp } - when pairing started
      
      const PAIRING_THRESHOLD_MS = 60000;  // 60 seconds to confirm pairing (towing)
      const BLE_STALE_DAYS = 7;  // Keep BLE positions for 7 days
      const POSITION_CHANGE_THRESHOLD = 0.0001; // ~10 meters
      
      // Legacy compatibility
      const beaconLastSeen = {};
      const BEACON_STALE_SECONDS = 86400 * 7; // 7 days - BLE keeps position until moved
      
      // Note: KNOWN_BEACONS already defined above at line 585
      
      // Calculate distance between two points in meters
      function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000; // Earth's radius in meters
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng/2) * Math.sin(dLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      // ===== RSSI-BASED DISTANCE ESTIMATION =====
      // Log-distance path loss model for BLE signal strength -> approximate meters
      const BLE_TX_POWER = -59;      // Teltonika Eye Beacon calibrated RSSI at 1 meter
      const BLE_PATH_LOSS_N = 2.5;   // Path loss exponent (mixed outdoor/near-vehicle environment)
      const BLE_MIN_SPREAD = 2;      // Min 2m visual offset ‚Äî never stack beacon on tracker icon
      const BLE_MAX_SPREAD = 30;     // Max 30m ‚Äî conservative cap so ground crew isn't misled

      function rssiToMeters(rssi) {
        if (rssi == null || !Number.isFinite(rssi)) return null;
        const d = Math.pow(10, (BLE_TX_POWER - rssi) / (10 * BLE_PATH_LOSS_N));
        return Math.max(BLE_MIN_SPREAD, Math.min(BLE_MAX_SPREAD, d));
      }

      function metersToLatOffset(m) { return m / 111320; }
      function metersToLngOffset(m, lat) { return m / (111320 * Math.cos(lat * Math.PI / 180)); }

      // ===== RSSI SMOOTHING (prevent jitter between 5s refreshes) =====
      const beaconRssiSmoothed = {};
      const RSSI_SMOOTH_ALPHA = 0.3; // Lower = smoother but slower to react

      function smoothRssi(mac, rawRssi) {
        if (rawRssi == null) return beaconRssiSmoothed[mac] || null;
        const prev = beaconRssiSmoothed[mac];
        const smoothed = prev != null ? RSSI_SMOOTH_ALPHA * rawRssi + (1 - RSSI_SMOOTH_ALPHA) * prev : rawRssi;
        beaconRssiSmoothed[mac] = smoothed;
        return smoothed;
      }

      // ===== RSSI-AWARE BEACON SPREAD =====
      // Beacons spread around their detecting tracker at RSSI-estimated distance
      // Each beacon gets a unique angle; distance proportional to signal strength
      function getBeaconRssiOffset(baseLat, rssi, beaconIndex, totalBeacons) {
        const meters = rssi != null ? rssiToMeters(rssi) : 0; // no RSSI => keep exact last location
        if (meters == null || totalBeacons <= 0) return { lat: 0, lng: 0 };
        const angle = (beaconIndex / totalBeacons) * 2 * Math.PI;
        return {
          lat: metersToLatOffset(meters) * Math.sin(angle),
          lng: metersToLngOffset(meters, baseLat) * Math.cos(angle)
        };
      }

      function forcedHostGroupKey(host) {
        return host ? String(host.id || host.label || "").toLowerCase() : "";
      }

      function spreadPixelsForGroup(count, zoom) {
        const z = Number.isFinite(zoom) ? zoom : 14;
        const base = z >= 17 ? 24 : z >= 15 ? 28 : 32;
        const extra = Math.max(0, count - 2) * 4;
        return Math.max(20, Math.min(44, base + extra));
      }

      function macStableAngle(mac) {
        const text = String(mac || "").toLowerCase();
        let hash = 0;
        for (let i = 0; i < text.length; i++) hash = ((hash << 5) - hash) + text.charCodeAt(i);
        const n = Math.abs(hash % 360);
        return (n * Math.PI) / 180;
      }

      function getForcedBeaconHostOffset(baseLat, baseLng, mac, host, forcedHostGroups) {
        const hostKey = forcedHostGroupKey(host);
        const group = forcedHostGroups[hostKey] || [];
        if (!group.length) return { lat: 0, lng: 0 };
        const idx = Math.max(0, group.indexOf(String(mac || "").toLowerCase()));
        const count = Math.max(1, group.length);
        const zoom = (typeof map !== "undefined" && map && typeof map.getZoom === "function") ? map.getZoom() : 14;
        const angle = (count === 1)
          ? macStableAngle(mac) // single beacon still gets a small stable gap from host
          : (idx / count) * 2 * Math.PI;
        if (typeof map !== "undefined" && map && typeof map.project === "function" && typeof map.unproject === "function") {
          const rPx = spreadPixelsForGroup(count, zoom);
          const c = map.project([baseLat, baseLng], zoom);
          const p = L.point(c.x + rPx * Math.cos(angle), c.y + rPx * Math.sin(angle));
          const ll = map.unproject(p, zoom);
          return { lat: ll.lat - baseLat, lng: ll.lng - baseLng };
        }
        const meters = 14 + (count - 1) * 3;
        return {
          lat: metersToLatOffset(meters) * Math.sin(angle),
          lng: metersToLngOffset(meters, baseLat) * Math.cos(angle)
        };
      }

      function isAllowedBleTrackerLabel(labelOrId) {
        const text = String(labelOrId || "").toLowerCase();
        return BLE_ALLOWED_TRACKER_TOKENS.some((token) => text.includes(token));
      }

      function normalizeTrackerLabel(labelOrId) {
        const text = String(labelOrId || "").trim();
        if (!text) return "";
        if (/skoda/i.test(text)) return "SKODA";
        return text;
      }

      function findForcedHostTracker(mac, trackerRows) {
        const hostHint = FORCED_BEACON_HOST_BY_MAC[String(mac || "").toLowerCase()];
        if (!hostHint || !Array.isArray(trackerRows)) return null;
        const needle = hostHint.toLowerCase();
        for (const row of trackerRows) {
          const label = String(row?.label || "").toLowerCase();
          const id = String(row?.tracker_id || "").toLowerCase();
          const lat = Number(row?.lat);
          const lng = Number(row?.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
          if (label.includes(needle) || id.includes(needle)) {
            return { lat, lng, label: normalizeTrackerLabel(row.label || row.tracker_id), id: row.tracker_id };
          }
        }
        return null;
      }

      function applyStrictBeaconInventory(combinedBle) {
        const filtered = {};
        STRICT_BEACON_MACS.forEach((lower) => {
          const existing = (combinedBle && (combinedBle[lower] || combinedBle[lower.toUpperCase()])) ? (combinedBle[lower] || combinedBle[lower.toUpperCase()]) : {};
          const known = KNOWN_BEACONS[lower] || KNOWN_BEACONS[lower.toUpperCase()] || {};
          // Always keep required beacons in model even if API omitted one this cycle.
          filtered[lower] = {
            mac: lower,
            name: known.name || `Beacon ${lower.slice(-4)}`,
            category: known.category || "Uncategorized",
            type: known.type || "eye_beacon",
            ...existing,
          };
        });
        return filtered;
      }

      // ===== MARKER SPREADING FOR OVERLAPPING TRACKER ICONS =====
      // Shared position group so trackers at same location spread in one circle (no stacking)
      const positionGroups = {};
      const SPREAD_DISTANCE = 0.00014; // ~15m radius so markers are readable and don't overlap

      function getSpreadOffset(lat, lng, markerId) {
        const key = `${lat.toFixed(4)},${lng.toFixed(4)}`;
        if (!positionGroups[key]) positionGroups[key] = [];
        let idx = positionGroups[key].indexOf(markerId);
        if (idx === -1) {
          idx = positionGroups[key].length;
          positionGroups[key].push(markerId);
        }
        const count = positionGroups[key].length;
        if (count <= 1) return { lat: 0, lng: 0 };
        const angle = (idx / count) * 2 * Math.PI;
        return {
          lat: SPREAD_DISTANCE * Math.sin(angle),
          lng: SPREAD_DISTANCE * Math.cos(angle)
        };
      }

      function clearMarkerPositions() {
        Object.keys(positionGroups).forEach(key => { positionGroups[key] = []; });
      }

      // Dynamic RSSI-based beacon positioning: beacons spread around their detecting tracker
      // at distances proportional to BLE signal strength. Updates position on every refresh.
      // Priority: RUTX11 (tractor) > FMC/OBD (vehicles) > Navixy cloud (fallback)
      function updateBeaconMarkersFromSQL(blePositionsData, trackerRows) {
        const now = Date.now();
        const macs = Object.keys(blePositionsData);
        lastBeaconPayload = { ...(blePositionsData || {}) };
        lastBeaconTrackerRows = Array.isArray(trackerRows) ? [...trackerRows] : [];
        beaconLinkLayer.clearLayers();
        beaconBadgeLayer.clearLayers();
        const expandedLayout = map.getZoom() >= BEACON_EXPAND_ZOOM;

        // Create tracker lookup for labels
        const trackerLookup = {};
        trackerRows.forEach(row => {
          trackerLookup[row.tracker_id] = { lat: row.lat, lng: row.lng, label: row.label };
          if (row.imei) trackerLookup[row.imei] = { lat: row.lat, lng: row.lng, label: row.label };
        });
        const allowedTrackers = trackerRows
          .filter((row) => !isXGpsHumanAgent(row))
          .filter((row) => isAllowedBleTrackerLabel(row.label) || isAllowedBleTrackerLabel(row.tracker_id))
          .map((row) => ({
            id: row.tracker_id,
            label: normalizeTrackerLabel(row.label || row.tracker_id),
            lat: Number(row.lat),
            lng: Number(row.lng),
          }))
          .filter((t) => Number.isFinite(t.lat) && Number.isFinite(t.lng));

        // Group beacons by detecting tracker for stable angle assignment
        const trackerBeaconGroups = {};
        Object.entries(blePositionsData).forEach(([mac, pos]) => {
          const tid = pos.last_tracker_id || "unknown";
          if (!trackerBeaconGroups[tid]) trackerBeaconGroups[tid] = [];
          trackerBeaconGroups[tid].push(mac);
        });
        // Sort each group by MAC for stable angle assignment across refreshes
        Object.values(trackerBeaconGroups).forEach(arr => arr.sort());

        // Precompute fixed beacon host groups (e.g. 4 around SKODA, 1 on 5032)
        const forcedHostByMac = {};
        const forcedHostGroups = {};
        Object.keys(FORCED_BEACON_HOST_BY_MAC).forEach((mac) => {
          const lower = String(mac || "").toLowerCase();
          const host = findForcedHostTracker(lower, trackerRows);
          if (!host) return;
          forcedHostByMac[lower] = host;
          const key = forcedHostGroupKey(host);
          if (!forcedHostGroups[key]) forcedHostGroups[key] = [];
          forcedHostGroups[key].push(lower);
        });
        Object.values(forcedHostGroups).forEach((arr) => arr.sort());

        console.log(`[BLE] Received ${macs.length} beacons from API (${Object.keys(trackerBeaconGroups).length} tracker groups)`);

        // Update/create markers for each beacon with RSSI-based offset from detecting tracker
        const renderedMacs = new Set();
        Object.entries(blePositionsData).forEach(([mac, pos]) => {
          const normalizedMac = String(mac || "").toLowerCase();
          if (!STRICT_BEACON_MACS.has(normalizedMac)) return;
          const forcedHost = forcedHostByMac[normalizedMac] || findForcedHostTracker(mac, trackerRows);
          const baseLat = Number(forcedHost ? forcedHost.lat : pos.lat);
          const baseLng = Number(forcedHost ? forcedHost.lng : pos.lng);

          if (!Number.isFinite(baseLat) || !Number.isFinite(baseLng)) {
            console.log(`[BLE] Skipping ${mac} - no position yet`);
            return;
          }
          renderedMacs.add(normalizedMac);

          // RSSI-based spread: distance from signal strength, angle from group index
          const trackerId = pos.last_tracker_id || "unknown";
          const group = trackerBeaconGroups[trackerId] || [mac];
          const idx = group.indexOf(mac);
          const totalBeacons = group.length;
          const rawRssi = pos.rssi != null ? Number(pos.rssi) : null;
          const rssi = smoothRssi(mac, rawRssi);
          const estDistance = rssiToMeters(rssi);
          const pairingSecondsRaw = Math.max(0, Number(pos.pairing_duration || 0));
          const isForcedHostBeacon = !!forcedHost;
          const hasLiveRssi = Number.isFinite(rawRssi);
          const isFollowingTracker = isForcedHostBeacon || (Boolean(pos.is_paired) && pairingSecondsRaw > 0 && hasLiveRssi);
          const offset = isForcedHostBeacon
            ? (expandedLayout ? getForcedBeaconHostOffset(baseLat, baseLng, normalizedMac, forcedHost, forcedHostGroups) : { lat: 0, lng: 0 })
            : (isFollowingTracker ? getBeaconRssiOffset(baseLat, rssi, idx, totalBeacons) : { lat: 0, lng: 0 });
          const lat = baseLat + offset.lat;
          const lng = baseLng + offset.lng;

          // Get BLE definition info
          const knownInfo = KNOWN_BEACONS[mac.toUpperCase()] || {};
          const name = pos.name || knownInfo.name || `Beacon ${mac.slice(-4)}`;
          const category = pos.category || knownInfo.category || "Uncategorized";
          const beaconType = pos.type || knownInfo.type || "eye_beacon";
          const sn = knownInfo.sn || "";

          // Get tracker label
          let trackerLabel = (forcedHost ? forcedHost.label : null) || pos.last_tracker_label ||
                             (trackerLookup[pos.last_tracker_id] ? trackerLookup[pos.last_tracker_id].label : pos.last_tracker_id) ||
                             "Unknown";
          if (!isAllowedBleTrackerLabel(trackerLabel) && !isAllowedBleTrackerLabel(pos.last_tracker_id)) {
            if (allowedTrackers.length) {
              let nearest = allowedTrackers[0];
              let minDistance = calculateDistance(baseLat, baseLng, nearest.lat, nearest.lng);
              for (let i = 1; i < allowedTrackers.length; i++) {
                const t = allowedTrackers[i];
                const d = calculateDistance(baseLat, baseLng, t.lat, t.lng);
                if (d < minDistance) {
                  minDistance = d;
                  nearest = t;
                }
              }
              trackerLabel = nearest.label;
            } else {
              trackerLabel = "SKODA";
            }
          } else {
            trackerLabel = normalizeTrackerLabel(trackerLabel);
          }

          const beacon = {
            mac,
            name,
            category,
            beaconType,
            sn,
            lat: baseLat, // Show tracker anchor position in popup
            lng: baseLng,
            battery: (pos.battery != null ? pos.battery : pos.battery_level),
            isPaired: isFollowingTracker,
            pairingDuration: pairingSecondsRaw,
            lastUpdate: pos.last_update || pos.last_seen || pos.updated_at || pos.updated,
            lastSeenAt: pos.last_seen || pos.last_update || pos.updated_at || pos.updated,
            lastSeen: pos.last_seen || pos.last_update || pos.updated_at || pos.updated,
            hostTrackerId: forcedHost ? forcedHost.id : pos.last_tracker_id,
            hostTrackerLabel: trackerLabel,
            rssi: rssi,
            estimatedDistance: estDistance,
          };

          let marker = beaconMarkers[mac];
          if (!marker) {
            // Create new marker
            marker = L.marker([lat, lng], {
              icon: createBeaconIcon(beaconType, category, 24, normalizedMac),
            }).bindPopup(beaconPopupHtml(beacon));

            const shape = beaconShapeForMac(normalizedMac, category);
            const shapeSymbols = { diamond: "‚óÜ", square: "‚ñ†", triangle: "‚ñ≤", circle: "‚óè", star: "‚òÖ", hexagon: "‚¨°", pentagon: "‚¨ü" };
            const symbol = shapeSymbols[shape] || "‚óè";
            marker.bindTooltip(`${symbol} ${name}`, {
              permanent: false,
              direction: "top",
              offset: [0, -12],
              className: "beacon-tooltip"
            });

            beaconMarkers[mac] = marker;
            marker.addTo(beaconLayer);
            console.log(`[BLE] Added marker: ${mac} (${name}) RSSI=${rawRssi} ~${estDistance ? estDistance.toFixed(1) + 'm' : 'N/A'} at (${lat.toFixed(6)}, ${lng.toFixed(6)})`);
          } else {
            // Update BOTH position and popup on every refresh (dynamic positioning)
            marker.setLatLng([lat, lng]);
            marker.setPopupContent(beaconPopupHtml(beacon));
          }
          if (expandedLayout && isForcedHostBeacon) {
            beaconLinkLayer.addLayer(L.polyline([[baseLat, baseLng], [lat, lng]], {
              color: "#64748b",
              weight: 1,
              opacity: 0.6,
              dashArray: "3,4",
              interactive: false
            }));
          }
        });

        if (!expandedLayout) {
          Object.entries(forcedHostGroups).forEach(([, macList]) => {
            if (!Array.isArray(macList) || macList.length <= 1) return;
            const anyMac = macList[0];
            const host = forcedHostByMac[anyMac];
            if (!host) return;
            const icon = L.divIcon({
              className: "",
              html: `<div class="beacon-host-badge">${macList.length}</div>`,
              iconSize: [24, 20],
              iconAnchor: [12, 10],
            });
            beaconBadgeLayer.addLayer(L.marker([host.lat, host.lng], { icon, interactive: false }));
          });
        }

        Object.keys(beaconMarkers).forEach((mac) => {
          const lower = String(mac || "").toLowerCase();
          if (!renderedMacs.has(lower)) {
            beaconLayer.removeLayer(beaconMarkers[mac]);
            delete beaconMarkers[mac];
          }
        });

        console.log(`[BLE] Total beacon markers: ${Object.keys(beaconMarkers).length}`);
      }

      // OLD: Keep for reference but not used
      function updateBeaconMarkers(trackerRows) {
        // Extract beacons from tracker data
        const beacons = extractBeaconsFromTrackers(trackerRows);
        const now = Date.now();
        
        // Create tracker lookup for distance calculation
        const trackerLookup = {};
        trackerRows.forEach(row => {
          trackerLookup[row.tracker_id] = { lat: row.lat, lng: row.lng, label: row.label };
        });

        // First pass: register all positions (trackers + beacons)
        trackerRows.forEach(row => {
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (Number.isFinite(lat) && Number.isFinite(lng)) {
            getSpreadOffset(lat, lng, `tracker_${row.tracker_id}`);
          }
        });

        // Update beacon positions with 60-second pairing logic
        beacons.forEach(beacon => {
          const trackerLat = Number(beacon.lat);
          const trackerLng = Number(beacon.lng);
          if (!Number.isFinite(trackerLat) || !Number.isFinite(trackerLng)) return;
          
          const mac = beacon.mac;
          const trackerId = beacon.hostTrackerId;
          const trackerLabel = beacon.hostTrackerLabel || trackerId;
          
          // Calculate distance from host tracker (beacon inherits tracker position)
          beacon.distanceFromTracker = 0; // BLE is detected by this tracker
          
          // Check if this is a new pairing or continuing pairing
          const currentPairing = blePairingTracker[mac];
          
          if (currentPairing !== trackerId) {
            // New tracker detecting this BLE - start pairing timer
            blePairingTracker[mac] = trackerId;
            blePairingStart[mac] = now;
            console.log(`BLE ${mac}: New detection by ${trackerLabel}, starting 60s timer`);
          }
          
          // Check if pairing has been stable for > 60 seconds
          const pairingDuration = now - (blePairingStart[mac] || now);
          const isPaired = pairingDuration >= PAIRING_THRESHOLD_MS;
          
          // Get or create BLE position record
          if (!blePositions[mac]) {
            // First time seeing this BLE - initialize with current position
            blePositions[mac] = {
              lat: trackerLat,
              lng: trackerLng,
              lastTracker: trackerId,
              lastTrackerLabel: trackerLabel,
              lastUpdate: new Date().toISOString(),
              distance: 0,
              isPaired: false
            };
            console.log(`BLE ${mac}: First detection, position set to (${trackerLat}, ${trackerLng})`);
          } else if (isPaired) {
            // Pairing confirmed (> 60 sec) - BLE is being towed, update position
            const oldLat = blePositions[mac].lat;
            const oldLng = blePositions[mac].lng;
            const moved = Math.abs(trackerLat - oldLat) > POSITION_CHANGE_THRESHOLD ||
                         Math.abs(trackerLng - oldLng) > POSITION_CHANGE_THRESHOLD;
            
            if (moved) {
              console.log(`BLE ${mac}: Paired > 60s with ${trackerLabel}, updating position`);
              blePositions[mac] = {
                lat: trackerLat,
                lng: trackerLng,
                lastTracker: trackerId,
                lastTrackerLabel: trackerLabel,
                lastUpdate: new Date().toISOString(),
                distance: 0,
                isPaired: true
              };
              
              // Save to database
              saveBlePosition(mac, {
                lat: trackerLat,
                lng: trackerLng,
                trackerId: trackerId,
                trackerLabel: trackerLabel,
                isPaired: true,
                pairingStart: blePairingStart[mac] ? new Date(blePairingStart[mac]).toISOString() : null,
                pairingDuration: Math.floor(pairingDuration / 1000),
                battery: beacon.battery,
                magnetStatus: beacon.magnet_sensors ? JSON.stringify(beacon.magnet_sensors) : null
              });
            }
          }
          // If not paired (< 60 sec), keep BLE at its last known position
          
          // Use stored BLE position (not tracker position)
          const blePos = blePositions[mac];
          beacon.bleLat = blePos.lat;
          beacon.bleLng = blePos.lng;
          beacon.lastSeenByTracker = blePos.lastTrackerLabel;
          beacon.lastSeenAt = blePos.lastUpdate;
          beacon.isPaired = isPaired;
          beacon.pairingDuration = Math.floor(pairingDuration / 1000);
          
          // Calculate distance from BLE stored position to current detecting tracker
          if (blePos.lat !== trackerLat || blePos.lng !== trackerLng) {
            beacon.distanceFromTracker = calculateDistance(blePos.lat, blePos.lng, trackerLat, trackerLng);
          }
          
          // Update beaconLastSeen for marker rendering
          beaconLastSeen[beacon.id] = {
            lat: blePos.lat,  // Use BLE's stored position
            lng: blePos.lng,
            timestamp: now,
            beacon: beacon,
            positionChanged: false
          };
        });

        // Update or create markers for all BLE positions
        // First, render all known BLE positions from blePositions
        Object.keys(blePositions).forEach(mac => {
          const blePos = blePositions[mac];
          const lat = blePos.lat;
          const lng = blePos.lng;
          
          // Find the beacon data if currently detected
          const currentBeacon = beacons.find(b => b.mac === mac);
          const beaconInfo = KNOWN_BEACONS[mac] || {};
          
          const beacon = currentBeacon || {
            id: mac,
            mac: mac,
            name: beaconInfo.name || mac,
            category: beaconInfo.category || "Uncategorized",
            beaconType: beaconInfo.type || "eye_beacon",
            sn: beaconInfo.sn || "",
            bleLat: lat,
            bleLng: lng,
            lastSeenByTracker: blePos.lastTrackerLabel,
            lastSeenAt: blePos.lastUpdate,
            isPaired: false,
            pairingDuration: 0,
            distanceFromTracker: 0,
          };
          
          // Calculate spread offset
          const offset = getSpreadOffset(lat, lng, `beacon_${mac}`);
          const markerLat = lat + offset.lat;
          const markerLng = lng + offset.lng;

          let marker = beaconMarkers[mac];
          if (!marker) {
            marker = L.marker([markerLat, markerLng], {
              icon: createBeaconIcon(beacon.beaconType, beacon.category, 24, mac),
            }).bindPopup(beaconPopupHtml(beacon));
            
            const shape = beaconShapeForMac(mac, beacon.category);
            const shapeSymbols = { diamond: "‚óÜ", square: "‚ñ†", triangle: "‚ñ≤", circle: "‚óè", star: "‚òÖ", hexagon: "‚¨°", pentagon: "‚¨ü" };
            const symbol = shapeSymbols[shape] || "‚óè";
            marker.bindTooltip(`${symbol} ${beacon.name || mac}`, {
              permanent: false,
              direction: "top",
              offset: [0, -12],
              className: `beacon-label`,
              opacity: 0.95,
            });
            
            beaconMarkers[mac] = marker;
            marker.addTo(beaconLayer);
          } else {
            // Update marker position and popup
            const currentLatLng = marker.getLatLng();
            if (Math.abs(currentLatLng.lat - markerLat) > 0.00001 || 
                Math.abs(currentLatLng.lng - markerLng) > 0.00001) {
              marker.setLatLng([markerLat, markerLng]);
            }
            marker.setPopupContent(beaconPopupHtml(beacon));
          }
        });

        // Clear position tracking for next update
        clearMarkerPositions();
      }

      // Eyebecon checkbox in layer control: only show/hide the legend menu (not the beacon objects on map)
      const beaconLegendOverlay = L.layerGroup();
      beaconLegendOverlay.on("add", () => {
        document.getElementById("beaconLegend")?.classList.remove("hidden");
      });
      beaconLegendOverlay.on("remove", () => {
        document.getElementById("beaconLegend")?.classList.add("hidden");
      });
      beaconLegendOverlay.addTo(map);

      const osmStreets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      const osmStandard = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      });
      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri",
        }
      );
      const baseLayers = {
        "OSM streets": osmStreets,
        OSM: osmStandard,
        "Satellite (Esri)": esriSat,
      };
      const overlayLayers = {
        "LLBG Gates/Zones": llbgLayer,
      };
      const layersControl = L.control
        .layers(
          baseLayers,
          overlayLayers,
          { position: "topright" }
        )
        .addTo(map);
      layersControl.addOverlay(debugLayer, "Debug");
      layersControl.addOverlay(legendLayer, "GSE Legend");
      layersControl.addOverlay(xGpsLayer, "üìç X-GPS (Human tracker)");
      layersControl.addOverlay(beaconLegendOverlay, "üîµ Eyebecon Tags");
      xGpsLayer.on("add", function () { showXGpsMarkers = true; syncXGpsCheckboxes(true); });
      xGpsLayer.on("remove", function () { showXGpsMarkers = false; syncXGpsCheckboxes(false); });

      const markers = {};
      let fitted = false;
      let activePopupId = null;
      let isRefreshing = false;
      let lastRows = [];
      const TABLE_COLUMNS = [
        { key: "gse", label: "GSE", value: (row) => formatLabel(row) },
        { key: "movement_status", label: "movement_status", value: (row) => formatFieldValue("movement_status", row.movement_status) },
        {
          key: "lat_lng",
          label: "lat / lng",
          value: (row) => (row.lat !== undefined && row.lng !== undefined ? `${row.lat} ; ${row.lng}` : "--"),
        },
        { key: "connection_status", label: "connection_status", value: (row) => formatFieldValue("connection_status", row.connection_status) },
        { key: "battery_level", label: "battery_level", value: (row) => row.battery_level ?? "--" },
        { key: "gsm_signal", label: "gsm_signal", value: (row) => row.gsm_signal ?? "--" },
        { key: "gps_signal", label: "gps_signal", value: (row) => row.gps_signal ?? "--" },
        { key: "engine_hours", label: "engine_hours", value: (row) => formatFieldValue("engine_hours", row.engine_hours) },
        { key: "next_service_hours", label: "next_service_hours", value: (row) => row.next_service_hours ?? "--" },
        { key: "Board voltage", label: "Board voltage", value: (row) => row["Board voltage"] ?? "--" },
        { key: "Fuel_level", label: "Fuel_level", value: (row) => row.Fuel_level ?? "--" },
        { key: "brake_pressure_actual", label: "brake_pressure_actual", value: (row) => row.brake_pressure_actual ?? "--" },
        { key: "engine_rpm", label: "engine_rpm", value: (row) => row.engine_rpm ?? "--" },
        { key: "gotis_status", label: "gotis_status", value: (row) => formatFieldValue("gotis_status", row.gotis_status) },
        { key: "pickup_state", label: "pickup_state", value: (row) => formatFieldValue("pickup_state", row.pickup_state) },
        { key: "Gottis", label: "Gottis", value: (row) => row.Gottis ?? "--" },
        { key: "Moving", label: "Moving", value: (row) => row.Moving ?? "--" },
        { key: "Pup_State", label: "Pup_State", value: (row) => row.Pup_State ?? "--" },
        { key: "Towing Detection", label: "Towing Detection", value: (row) => row["Towing Detection"] ?? "--" },
        { key: "Ignition", label: "Ignition", value: (row) => row.Ignition ?? row.ignition ?? "--" },
        { key: "beacon_name", label: "Beacon name", value: (row) => row.EyeBecon ?? "--" },
        { key: "beacon_id", label: "Beacon ID", value: (row) => row["BLE: ID"] ?? "--" },
        { key: "beacon_key", label: "Beacon key", value: (row) => row["Hardware key"] ?? "--" },
        { key: "last_update", label: "Last update", value: (row) => row.last_update || row.gps_updated || "--" },
      ];
      const STAR_SECTIONS = [
        {
          title: "Status / Position",
          timestampField: "movement_status",
          fields: [
            { label: "movement_status", keys: ["movement_status"], updatedKey: "movement_status__updated" },
            { label: "lat / lng", keys: ["lat_lng"], updatedKey: "lat_lng__updated" },
          ],
        },
        {
          title: "GPS device / signals",
          timestampField: "battery_level",
          fields: [
            { label: "connection_status", keys: ["connection_status"], updatedKey: "connection_status__updated" },
            { label: "battery_level", keys: ["battery_level"], updatedKey: "battery_level__updated" },
            { label: "gsm_signal", keys: ["gsm_signal"], updatedKey: "gsm_signal__updated" },
            { label: "gps_signal", keys: ["gps_signal"], updatedKey: "gps_signal__updated" },
          ],
        },
        {
          title: "Engine hours",
          timestampField: "engine_hours",
          fields: [
            { label: "engine_hours", keys: ["engine_hours"], updatedKey: "engine_hours__updated" },
            { label: "next_service_hours", keys: ["next_service_hours"], updatedKey: "next_service_hours__updated" },
          ],
        },
        {
          title: "Sensor last read",
          timestampField: "Board voltage",
          fields: [
            { label: "Board voltage", keys: ["Board voltage", "board_voltage"], updatedKey: "Board voltage__updated" },
            { label: "Fuel_level", keys: ["Fuel_level", "Fuel level"], updatedKey: "Fuel_level__updated" },
            { label: "brake_pressure_actual", keys: ["brake_pressure_actual"], updatedKey: "brake_pressure_actual__updated" },
            { label: "engine_rpm", keys: ["engine_rpm"], updatedKey: "engine_rpm__updated" },
          ],
        },
        {
          title: "Gotis System",
          timestampField: "gotis_status",
          fields: [
            { label: "gotis_status", keys: ["gotis_status"], updatedKey: "gotis_status__updated" },
            { label: "pickup_state", keys: ["pickup_state"], updatedKey: "pickup_state__updated" },
            { label: "Gottis", keys: ["Gottis"], updatedKey: "Gottis__updated" },
            { label: "Moving", keys: ["Moving"], updatedKey: "Moving__updated" },
          ],
        },
        {
          title: "Pup System",
          timestampField: "Pup_State",
          fields: [
            { label: "Pup_State", keys: ["Pup_State"], updatedKey: "Pup_State__updated" },
            { label: "Towing Detection", keys: ["Towing Detection", "Towing_Detection"], updatedKey: "Towing Detection__updated" },
          ],
        },
        {
          title: "Inputs",
          timestampField: "Ignition",
          fields: [{ label: "Ignition", keys: ["Ignition", "ignition"], updatedKey: "Ignition__updated" }],
        },
      ];
      const iconCache = new Map();
      const lastPositions = new Map();
      const clearButton = document.getElementById("clearPopup");
      const relinkButton = document.getElementById("relinkBtn");
      const relinkButtonTop = document.getElementById("relinkBtnTop");
      const relinkStatus = document.getElementById("relinkStatus");
      const debugOverlay = document.getElementById("debugOverlay");
      const legendOverlay = document.getElementById("legendOverlay");

      if (clearButton) {
        clearButton.addEventListener("click", () => {
          Object.values(markers).forEach((marker) => marker.closePopup());
          activePopupId = null;
        });
      }

      function setRelinkUi(isBusy, text) {
        if (relinkButton) relinkButton.disabled = !!isBusy;
        if (relinkButtonTop) relinkButtonTop.disabled = !!isBusy;
        if (relinkStatus) relinkStatus.textContent = text || "";
      }

      function isIgnoredTracker(rowOrId, maybeLabel) {
        const id = typeof rowOrId === "object" ? String(rowOrId?.tracker_id || "") : String(rowOrId || "");
        const label = typeof rowOrId === "object" ? String(rowOrId?.label || "") : String(maybeLabel || "");
        const s = `${id} ${label}`.toLowerCase();
        return s.includes("rutx11");
      }

      function clearBeaconRuntimeState() {
        Object.keys(blePositions).forEach((k) => delete blePositions[k]);
        Object.keys(blePairingTracker).forEach((k) => delete blePairingTracker[k]);
        Object.keys(blePairingStart).forEach((k) => delete blePairingStart[k]);
        Object.keys(beaconLastSeen).forEach((k) => delete beaconLastSeen[k]);
        Object.keys(beaconRssiSmoothed).forEach((k) => delete beaconRssiSmoothed[k]);
        beaconLayer.clearLayers();
        Object.keys(beaconMarkers).forEach((k) => delete beaconMarkers[k]);
      }

      const viewTabs = document.querySelectorAll(".view-tab");
      const mapView = document.getElementById("mapView");
      const tableView = document.getElementById("tableView");
      viewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          viewTabs.forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          const view = tab.dataset.view;
          if (view === "table") {
            mapView.classList.remove("active");
            tableView.classList.add("active");
          } else {
            tableView.classList.remove("active");
            mapView.classList.add("active");
            map.invalidateSize();
          }
        });
      });

      map.on("overlayadd", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.remove("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.remove("hidden");
        }
      });
      map.on("overlayremove", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.add("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.add("hidden");
        }
      });

      function iconPathForRow(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        const name = `${label} ${group}`;
        if (label.includes("5032")) {
          return "Pictures/towing_barless_transparent.png";
        }
        if (label.includes("6074")) {
          return "Pictures/Champ70_transparent.png";
        }
        if (name.includes("towing") || name.includes("tow") || name.includes("??????")) {
          return "Pictures/TowBar.png";
        }
        if (name.includes("loader") || name.includes("??????")) {
          return "Pictures/Loader.png";
        }
        if (name.includes("acu") || name.includes("a/c")) {
          return "Pictures/TLD ACU.png";
        }
        if (name.includes("gpu")) {
          return "Pictures/TLD GPU.png";
        }
        if (name.includes("stair") || name.includes("stairs")) {
          return "Pictures/staires.png";
        }
        if (name.includes("manito")) {
          return "Pictures/Manito.png";
        }
        if (name.includes("tractor") || name.includes("tracktor") || name.includes("trac")) {
          return "Pictures/Tracktor.png";
        }
        return "Pictures/Aviation1.jpg";
      }

      function markerSizeForZoom(zoom) {
        const safeZoom = Number.isFinite(zoom) ? zoom : 13;
        const size = 14 + (safeZoom - 10) * 3;
        return Math.max(20, Math.min(56, Math.round(size)));
      }

      function markerIcon(path, size) {
        const key = `${path}|${size}`;
        if (!iconCache.has(key)) {
          iconCache.set(
            key,
            L.icon({
              iconUrl: encodeURI(path),
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2],
              popupAnchor: [0, -size / 2],
            })
          );
        }
        return iconCache.get(key);
      }

      function updateMarkerIcons() {
        const size = markerSizeForZoom(map.getZoom());
        Object.values(markers).forEach((marker) => {
          const iconPath = marker.options.iconPath || "Pictures/Aviation1.jpg";
          marker.setIcon(markerIcon(iconPath, size));
        });
      }

      map.on("zoomend", () => {
        updateMarkerIcons();
        if (Object.keys(lastBeaconPayload || {}).length) {
          updateBeaconMarkersFromSQL(lastBeaconPayload, lastBeaconTrackerRows || []);
        }
      });

      const LOW_FUEL_THRESHOLD = 20;
      const LOW_BATTERY_THRESHOLD = 24;
      const MOVE_DISTANCE_METERS = 10;

      function parseNumber(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const num = Number(String(value).replace(/[^\d.-]/g, ""));
        return Number.isFinite(num) ? num : null;
      }

      function parseBoolean(value) {
        if (value === null || value === undefined) {
          return false;
        }
        if (typeof value === "boolean") {
          return value;
        }
        const text = String(value).trim().toLowerCase();
        return text === "on" || text === "true" || text === "1" || text === "yes" || text === "active";
      }

      function distanceMeters(lat1, lon1, lat2, lon2) {
        const toRad = (deg) => (deg * Math.PI) / 180;
        const r = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return r * c;
      }

      function updateDistance(id, lat, lng) {
        const prev = lastPositions.get(id);
        lastPositions.set(id, { lat, lng });
        if (!prev) {
          return 0;
        }
        return distanceMeters(prev.lat, prev.lng, lat, lng);
      }

      function isMoving(row) {
        const status = String(row.movement_status || "").toLowerCase();
        if (status.includes("moving")) {
          return true;
        }
        const speed = parseNumber(row.speed ?? row.Speed);
        return speed !== null ? speed > 0.5 : false;
      }

      function isIgnitionOn(row) {
        const ignition =
          row.Ignition ??
          row.ignition ??
          row["Ignition"] ??
          row["Ignition status"] ??
          row["ignition_status"] ??
          row.input1 ??
          row["input1"] ??
          row["Input1"] ??
          row["Input 1"];
        if (parseBoolean(ignition)) {
          return true;
        }
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        return rpm !== null ? rpm > 0 : false;
      }

      function isLoader(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        return label.includes("loader") || group.includes("loader") || label.includes("6074");
      }

      function isWorking(row, moving) {
        if (moving) {
          return false;
        }
        if (isIgnitionOn(row)) {
          return true;
        }
        const workingFlag =
          parseBoolean(row.Working) ||
          parseBoolean(row.working) ||
          parseBoolean(row["Working-Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer_Extract"]);
        const oilPressure = parseNumber(row["Engine_O.P"] ?? row.Engine_O_P ?? row.Engine_OP);
        if (workingFlag) {
          return true;
        }
        if (isLoader(row) && oilPressure !== null) {
          return oilPressure > 2;
        }
        return false;
      }

      function isAlert(row) {
        const fuel = parseNumber(row.Fuel_level ?? row.Fuel ?? row["Fuel level"]);
        const battery = parseNumber(
          row["Battery level"] ??
            row.battery_level ??
            row.Voltage ??
            row.voltage ??
            row["Board voltage"]
        );
        const lowFuel = fuel !== null ? fuel < LOW_FUEL_THRESHOLD : false;
        const lowBattery = battery !== null ? battery < LOW_BATTERY_THRESHOLD : false;
        const nextService = parseNumber(row.next_service_hours ?? row["Next Service"]);
        const alertFlag =
          parseBoolean(row.Alert) ||
          parseBoolean(row.alert) ||
          parseBoolean(row["Repair requested"]);
        const nextServiceDue = nextService !== null ? nextService <= 0 : false;
        return lowFuel || nextServiceDue || alertFlag || lowBattery;
      }

      function statusLabel(row) {
        return row.movement_status || row.connection_status || "unknown";
      }

      function statusClass(row, moving, distanceMetersValue) {
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        const maintenance =
          parseBoolean(row["Maintenance zone"]) ||
          parseBoolean(row.maintenance_zone) ||
          parseBoolean(row["In maintenance"]);
        const navixyStatus = String(row.movement_status || row.connection_status || "")
          .toLowerCase()
          .trim();

        if (isAlert(row)) {
          return "gse-status-alert";
        }
        if (maintenance) {
          return "gse-status-maintenance";
        }
        if (parseNumber(row.Voltage ?? row.voltage) !== null) {
          const voltage = parseNumber(row.Voltage ?? row.voltage);
          if (voltage !== null && voltage < LOW_BATTERY_THRESHOLD) {
            return "gse-status-low-battery";
          }
        }
        if (isWorking(row, moving)) {
          return "gse-status-working";
        }
        if (navixyStatus.includes("moving")) {
          return "gse-status-moving";
        }
        if (navixyStatus.includes("idle")) {
          return "gse-status-idle";
        }
        if (
          navixyStatus.includes("standstill") ||
          navixyStatus.includes("park") ||
          navixyStatus.includes("stopp")
        ) {
          return "gse-status-available";
        }
        if (navixyStatus.includes("offline")) {
          return "gse-status-stop";
        }
        if (moving || distanceMetersValue > MOVE_DISTANCE_METERS) {
          return "gse-status-moving";
        }
        if (rpm !== null && rpm !== 0) {
          return "gse-status-in-use";
        }
        if (rpm !== null && rpm < 2000 && distanceMetersValue <= MOVE_DISTANCE_METERS) {
          return "gse-status-idle";
        }
        if (isIgnitionOn(row)) {
          return "gse-status-ignition";
        }
        return "gse-status-available";
      }

      function updateTooltip(marker, text, className) {
        if (!marker.getTooltip()) {
          marker.bindTooltip(text, {
            permanent: true,
            direction: "top",
            offset: [0, -12],
            className: `gse-label ${className}`,
          });
          return;
        }
        marker.setTooltipContent(text);
        marker.getTooltip().options.className = `gse-label ${className}`;
        if (marker.getTooltip()._container) {
          marker.getTooltip()._container.className = `leaflet-tooltip gse-label ${className}`;
        }
      }

      function formatLabel(row) {
        const label = row.label || row.tracker_id || "";
        const match = String(label).match(/(\d{4})/);
        return match ? match[1] : String(label);
      }

      function formatStatus(row) {
        return row.movement_status || row.connection_status || "--";
      }

      function formatSensor(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("Fuel", row.Fuel_level ?? row.Fuel);
        add("Voltage", row["Board voltage"] ?? row.Voltage ?? row.voltage);
        add("EngTemp", row.Engine_Temp ?? row.engine_temperature);
        add("EngOP", row["Engine_O.P"]);
        add("RPM", row.engine_rpm);
        return parts.length ? parts.join(" | ") : "--";
      }

      function formatBeacon(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("BLE", row["BLE: ID"]);
        add("EyeBecon", row.EyeBecon);
        add("Key", row["Hardware key"]);
        return parts.length ? parts.join(" | ") : "--";
      }

      function pickValue(row, keys) {
        for (const key of keys) {
          const value = row[key];
          if (value !== null && value !== undefined && value !== "") {
            return value;
          }
        }
        return null;
      }

      function formatNumberWithUnits(value, decimals = 2) {
        if (value === null || value === undefined || value === "") {
          return value;
        }
        const text = String(value);
        const match = text.match(/-?\d+(?:\.\d+)?/);
        if (!match) {
          return value;
        }
        const num = Number(match[0]);
        if (!Number.isFinite(num)) {
          return value;
        }
        const units = text.replace(match[0], "").trim();
        const formatted = num.toFixed(decimals);
        return units ? `${formatted} ${units}` : formatted;
      }

      function formatFieldValue(label, value) {
        if (value === null || value === undefined || value === "") {
          return "--";
        }
        let text = String(value);
        if (text.endsWith(" custom")) {
          text = text.replace(" custom", "");
        }
        if (label === "movement_status") {
          if (text.toLowerCase() === "parked") {
            return "Standstill";
          }
        }
        if (label === "connection_status") {
          if (text.toLowerCase() === "active") {
            return "Online";
          }
        }
        if (label === "engine_hours") {
          return formatNumberWithUnits(text, 2);
        }
        return value;
      }

      function formatValue(value) {
        if (value === null || value === undefined || value === "") {
          return "--";
        }
        return `${value}`;
      }

      function sectionTimestamp(row, section) {
        if (section.timestampField) {
          const match = section.fields.find((field) => field.label === section.timestampField);
          if (match) {
            return match.updatedKey ? row[match.updatedKey] : null;
          }
        }
        return null;
      }

      function renderTable(rows) {
        const head = document.getElementById("gseTableHead");
        const body = document.getElementById("gseTableBody");
        if (!head || !body) {
          return;
        }
        head.innerHTML = `<tr>${TABLE_COLUMNS.map((col) => `<th>${col.label}</th>`).join("")}</tr>`;
        body.innerHTML = rows
          .map((row) => {
            const cells = TABLE_COLUMNS.map((col) => {
              const value = col.value(row);
              const safeValue = value !== null && value !== undefined && value !== "" ? value : "--";
              const cls = col.key === "gse" ? " class=\"gse-table-key\"" : "";
              return `<td${cls}>${safeValue}</td>`;
            }).join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");
      }

      function popupHtml(row) {
        const label = row.label || row.tracker_id || "tracker";
        const sections = STAR_SECTIONS.map((section) => {
          const sectionTs = sectionTimestamp(row, section);
          const headerTs = sectionTs ? `<span class="gse-ts">${sectionTs}</span>` : "";
          const items = section.fields
            .map((field) => {
              const raw = pickValue(row, field.keys);
              const value = formatFieldValue(field.label, raw);
              return `<div class="gse-row"><span class="gse-label">${field.label}</span><span class="gse-value">${formatValue(
                value
              )}</span></div>`;
            })
            .join("");
          return `<div class="gse-section">${section.title}${headerTs}</div>${items}`;
        }).join("");
        return `<div class="gse-popup gse-style-${POPUP_STYLE}"><h4>${label}</h4>${sections}</div>`;
      }

      // X-GPS = Human Agent tracker only (e.g. Golan-X-GPS). SKODA is a GSE asset ‚Äì never hide it.
      function isXGpsHumanAgent(row) {
        const label = String(row.label || row.tracker_id || "").toLowerCase().trim();
        if (/^skoda$/.test(label)) return false;
        return /golan-x-gps|x-gps\b/.test(label);
      }

      function updateMarkers(rows) {
        isRefreshing = true;
        if (!map.hasLayer(layer)) layer.addTo(map);
        const bounds = [];
        const seen = new Set();
        const xgpsSeen = new Set();

        rows.forEach((row) => {
          if (isIgnoredTracker(row)) return;
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
          const label = row.label || row.tracker_id || "tracker";
          const shortMatch = String(label).match(/(\d{4})/);
          const shortLabel = shortMatch ? shortMatch[1] : label;
          const id = String(row.tracker_id || label);
          const isXgps = isXGpsHumanAgent(row);

          if (isXgps) {
            if (!showXGpsMarkers) return;
            xgpsSeen.add(id);
            const iconPath = iconPathForRow(row);
            const size = markerSizeForZoom(map.getZoom());
            const distanceMetersValue = updateDistance(id, lat, lng);
            const moving = isMoving(row) || distanceMetersValue > MOVE_DISTANCE_METERS;
            const labelClass = statusClass(row, moving, distanceMetersValue);
            const spreadOffset = getSpreadOffset(lat, lng, `tracker_${id}`);
            const markerLat = lat + spreadOffset.lat;
            const markerLng = lng + spreadOffset.lng;
            let marker = markersXgps[id];
            if (!marker) {
              marker = L.marker([markerLat, markerLng], { icon: markerIcon(iconPath, size), iconPath })
                .bindPopup(popupHtml(row));
              updateTooltip(marker, shortLabel, labelClass);
              marker.on("click", () => { marker.openPopup(); activePopupId = id; });
              marker.on("popupclose", () => { if (!isRefreshing && activePopupId === id) activePopupId = null; });
              markersXgps[id] = marker;
              marker.addTo(xGpsLayer);
            } else {
              marker.setLatLng([markerLat, markerLng]);
              marker.setIcon(markerIcon(iconPath, size));
              marker.setPopupContent(popupHtml(row));
              updateTooltip(marker, shortLabel, labelClass);
            }
            return;
          }

          seen.add(id);
          const iconPath = iconPathForRow(row);
          const size = markerSizeForZoom(map.getZoom());
          const distanceMetersValue = updateDistance(id, lat, lng);
          const moving = isMoving(row) || distanceMetersValue > MOVE_DISTANCE_METERS;
          const labelClass = statusClass(row, moving, distanceMetersValue);
          const spreadOffset = getSpreadOffset(lat, lng, `tracker_${id}`);
          const markerLat = lat + spreadOffset.lat;
          const markerLng = lng + spreadOffset.lng;
          let marker = markers[id];
          if (!marker) {
            marker = L.marker([markerLat, markerLng], { icon: markerIcon(iconPath, size), iconPath })
              .bindPopup(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
            marker.off("click", marker._openPopup);
            marker.on("click", () => { marker.openPopup(); activePopupId = id; });
            marker.on("popupclose", () => { if (!isRefreshing && activePopupId === id) activePopupId = null; });
            markers[id] = marker;
            marker.addTo(layer);
          } else {
            marker.setLatLng([markerLat, markerLng]);
            marker.setIcon(markerIcon(iconPath, size));
            marker.options.iconPath = iconPath;
            let popupScrollTop = null;
            if (activePopupId === id) {
              const popupEl = marker.getPopup()?.getElement();
              const contentEl = popupEl?.querySelector(".gse-popup");
              if (contentEl) popupScrollTop = contentEl.scrollTop;
            }
            marker.setPopupContent(popupHtml(row));
            if (popupScrollTop !== null) {
              setTimeout(() => {
                const popupEl = marker.getPopup()?.getElement();
                const contentEl = popupEl?.querySelector(".gse-popup");
                if (contentEl) contentEl.scrollTop = popupScrollTop;
              }, 0);
            }
            updateTooltip(marker, shortLabel, labelClass);
          }
          if (!String(label).toLowerCase().includes("skoda")) bounds.push([lat, lng]);
        });

        Object.keys(markersXgps).forEach((key) => {
          if (!xgpsSeen.has(key)) {
            xGpsLayer.removeLayer(markersXgps[key]);
            delete markersXgps[key];
            if (activePopupId === key) activePopupId = null;
          }
        });
        Object.keys(markers).forEach((key) => {
          if (!seen.has(key)) {
            layer.removeLayer(markers[key]);
            delete markers[key];
            if (activePopupId === key) activePopupId = null;
          }
        });

        const statusEl = document.getElementById("mapStatus");
        const debugEl = document.getElementById("mapDebug");
        if (statusEl) {
          const visibleTrackers = rows.filter((r) => !isIgnoredTracker(r)).length;
          statusEl.textContent = `Trackers: ${visibleTrackers} | Markers: ${bounds.length}`;
        }
        if (debugEl) {
          const first = rows.find((row) => Number.isFinite(Number(row.lat)) && Number.isFinite(Number(row.lng)));
          const zoom = map.getZoom();
          debugEl.textContent = first
            ? `| zoom ${zoom} | ${Number(first.lat).toFixed(5)}, ${Number(first.lng).toFixed(5)}`
            : `| zoom ${zoom} | no lat/lng`;
        }

        if (!fitted) {
          if (bounds.length === 1) {
            map.setView(bounds[0], 15);
          } else {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          fitted = true;
        }
        if (activePopupId && markers[activePopupId]) {
          markers[activePopupId].openPopup();
        }
        isRefreshing = false;
      }

      // Save BLE position to database when pairing confirmed
      async function saveBlePosition(mac, data) {
        try {
          const apiUrl = LIVE_API_URL || DATA_SOURCES.motorized_gse;
          const baseUrl = apiUrl.replace('/data', '');
          await fetch(`${baseUrl}/ble/position`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              mac: mac,
              lat: data.lat,
              lng: data.lng,
              tracker_id: data.trackerId,
              tracker_label: data.trackerLabel,
              is_paired: data.isPaired,
              pairing_start: data.pairingStart,
              pairing_duration_sec: data.pairingDuration,
              battery_percent: data.battery,
              magnet_status: data.magnetStatus
            })
          });
          console.log(`[DB] Saved BLE position: ${mac}`);
        } catch (e) {
          console.warn(`[DB] Failed to save BLE position: ${e}`);
        }
      }
      
      function mergeBeaconsFromRows(combinedBle, rows, forceRelink) {
        rows.forEach(row => {
          if (isIgnoredTracker(row)) return;
          if (!row.beacons || !Array.isArray(row.beacons)) return;
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
          row.beacons.forEach(beacon => {
            const mac = (beacon.mac || "").toLowerCase();
            if (!mac) return;
            const existing = combinedBle[mac];
            const hasStored = existing && Number.isFinite(Number(existing.lat)) && Number.isFinite(Number(existing.lng));
            if (hasStored && !forceRelink) return;
            const known = KNOWN_BEACONS[mac] || KNOWN_BEACONS[mac.toUpperCase()] || {};
            const fromRow = {
              lat, lng,
              name: known.name || beacon.name || `Beacon ${mac.slice(-4)}`,
              category: known.category || beacon.category || "Uncategorized",
              type: known.type || beacon.beaconType || "eye_beacon",
              last_tracker_id: row.tracker_id,
              last_tracker_label: row.label || String(row.tracker_id),
              last_update: new Date().toISOString(),
              last_seen: new Date().toISOString(),
              is_paired: false,
            };
            // Beacon data (battery, last_update, etc.) comes only from broker; keep broker fields when present
            if (existing && (existing.battery != null || existing.last_update != null)) {
              combinedBle[mac] = {
                ...fromRow,
                battery: existing.battery != null ? existing.battery : existing.battery_level,
                last_update: existing.last_update || fromRow.last_update,
                last_seen: existing.last_seen || existing.last_update || fromRow.last_seen,
                rssi: existing.rssi,
                last_tracker_id: forceRelink ? fromRow.last_tracker_id : (existing.last_tracker_id ?? fromRow.last_tracker_id),
                last_tracker_label: forceRelink ? fromRow.last_tracker_label : (existing.last_tracker_label || fromRow.last_tracker_label),
                is_paired: existing.is_paired,
                pairing_duration: existing.pairing_duration
              };
            } else {
              combinedBle[mac] = fromRow;
            }
          });
        });
      }

      function sanitizeBeaconPositions(combinedBle, trackerRows, options = {}) {
        const forceAllToNearestTracker = !!options.forceAllToNearestTracker;
        const activeTrackers = (trackerRows || [])
          .filter((row) => !isIgnoredTracker(row))
          .map((row) => ({
            id: row.tracker_id,
            label: row.label || String(row.tracker_id),
            lat: Number(row.lat),
            lng: Number(row.lng),
          }))
          .filter((t) => Number.isFinite(t.lat) && Number.isFinite(t.lng));

        if (!activeTrackers.length) return combinedBle;

        const maxAllowedMeters = 2000;
        Object.keys(combinedBle).forEach((mac) => {
          const pos = combinedBle[mac] || {};
          const lat = Number(pos.lat);
          const lng = Number(pos.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
          const ignoredTracker = isIgnoredTracker(pos.last_tracker_id, pos.last_tracker_label);
          let nearest = null;
          let nearestDistance = Infinity;
          activeTrackers.forEach((t) => {
            const d = calculateDistance(lat, lng, t.lat, t.lng);
            if (d < nearestDistance) {
              nearestDistance = d;
              nearest = t;
            }
          });
          if (!nearest) return;
          const shouldSnapToNearest = forceAllToNearestTracker || nearestDistance > maxAllowedMeters;
          if (shouldSnapToNearest) {
            combinedBle[mac] = {
              ...pos,
              lat: nearest.lat,
              lng: nearest.lng,
              last_tracker_id: nearest.id,
              last_tracker_label: nearest.label,
              last_update: new Date().toISOString(),
            };
          } else if (ignoredTracker && !forceAllToNearestTracker) {
            // Keep last coordinates, but normalize label so popup does not show RUTX11.
            combinedBle[mac] = {
              ...pos,
              last_tracker_id: nearest.id,
              last_tracker_label: nearest.label,
            };
          }
        });
        return combinedBle;
      }

      let loadInProgress = false;
      let hasLoadedOnce = false;
      function setStatus(msg, brokerOffline) {
        const el = document.getElementById("mapStatus");
        if (el) el.textContent = msg;
        const w = document.getElementById("brokerWarning");
        if (w) {
          if (brokerOffline) {
            w.textContent = "Broker offline - no beacon data. Run .\\start_all.ps1";
            w.classList.remove("hidden");
          } else {
            w.classList.add("hidden");
          }
        }
      }
      function dataFetch(url) {
        const opts = (url && url.indexOf("ngrok") !== -1) ? { headers: { "ngrok-skip-browser-warning": "true" } } : {};
        return fetch(url, opts);
      }

      async function loadData(options = {}) {
        if (loadInProgress) return;
        loadInProgress = true;
        const forceRelink = !!options.forceRelink;
        if (!hasLoadedOnce) setStatus("Loading‚Ä¶");
        if (forceRelink) setRelinkUi(true, "Relinking...");
        try {
          Object.keys(positionGroups).forEach(key => delete positionGroups[key]);
          let payloadNavixy = null;
          let payloadDirect = null;

          if (currentDataSource === "both") {
            const [res1, res2] = await Promise.allSettled([
              dataFetch(DATA_SOURCES.motorized_gse).then(r => r.ok ? r.json() : Promise.reject(new Error("8767 failed"))),
              dataFetch(DATA_SOURCES.direct).then(r => r.ok ? r.json() : Promise.reject(new Error("8768 failed")))
            ]);
            payloadNavixy = res1.status === "fulfilled" ? res1.value : null;
            payloadDirect = res2.status === "fulfilled" ? res2.value : null;
            lastRows = (payloadNavixy && payloadNavixy.rows) ? payloadNavixy.rows.filter((r) => !isIgnoredTracker(r)) : [];
            if (payloadNavixy && payloadNavixy.ble_positions && Object.keys(blePositions).length === 0) {
              Object.entries(payloadNavixy.ble_positions).forEach(([mac, pos]) => {
                blePositions[mac] = { lat: pos.lat, lng: pos.lng, lastTracker: pos.last_tracker_id, lastTrackerLabel: pos.last_tracker_label || "Unknown", lastUpdate: pos.last_update, isPaired: pos.is_paired };
              });
            }
            // Beacon data (battery, last_update, last_tracker_*, etc.) comes ONLY from broker. Navixy supplies location only when broker has none.
            const combinedBle = { ...DIRECT_BEACON_POSITIONS_FALLBACK };
            if (payloadDirect && payloadDirect.ble_positions) Object.assign(combinedBle, payloadDirect.ble_positions);
            if (payloadNavixy && payloadNavixy.ble_positions) {
              Object.entries(payloadNavixy.ble_positions).forEach(([mac, pos]) => {
                const existing = combinedBle[mac];
                if (!existing) {
                  combinedBle[mac] = { ...pos };
                } else {
                  // Keep broker fields; only fill lat/lng from Navixy if broker has no position
                  if ((existing.lat == null || existing.lng == null) && pos.lat != null && pos.lng != null) {
                    combinedBle[mac] = { ...existing, lat: pos.lat, lng: pos.lng };
                  }
                }
              });
            }
            const directRows = (payloadDirect && payloadDirect.rows) ? payloadDirect.rows : [];
            mergeBeaconsFromRows(combinedBle, directRows, forceRelink);
            mergeBeaconsFromRows(combinedBle, lastRows, forceRelink);
            const strictCombined = applyStrictBeaconInventory(combinedBle);
            sanitizeBeaconPositions(strictCombined, lastRows, {
              forceAllToNearestTracker: forceRelink
            });
            updateMarkers(lastRows);
            renderTable(lastRows);
            updateBeaconMarkersFromSQL(strictCombined, lastRows);
            let msg = lastRows.length ? `Both: ${lastRows.length} trackers, ${Object.keys(strictCombined).length} beacons` : (payloadNavixy ? "Both: no trackers" : "Broker offline - run .\\start_all.ps1");
            if (!payloadDirect) { msg = "Broker offline - run .\\start_all.ps1 to get beacon data"; setStatus(msg, true); }
            else setStatus(msg, false);
          } else if (currentDataSource === "direct") {
            try {
              const response = await dataFetch(DATA_SOURCES.direct);
              payloadDirect = response.ok ? await response.json() : null;
            } catch (e) { payloadDirect = null; }
            lastRows = [];
            const fromBroker = (payloadDirect && payloadDirect.ble_positions) ? payloadDirect.ble_positions : {};
            const combinedBle = { ...DIRECT_BEACON_POSITIONS_FALLBACK };
            Object.assign(combinedBle, fromBroker);
            const directRows = (payloadDirect && payloadDirect.rows) ? payloadDirect.rows.filter((r) => !isIgnoredTracker(r)) : [];
            mergeBeaconsFromRows(combinedBle, directRows, forceRelink);
            const strictCombined = applyStrictBeaconInventory(combinedBle);
            sanitizeBeaconPositions(strictCombined, directRows, {
              forceAllToNearestTracker: forceRelink
            });
            updateMarkers([]);
            renderTable([]);
            updateBeaconMarkersFromSQL(strictCombined, []);
            let msg = Object.keys(strictCombined).length ? `Direct: ${Object.keys(strictCombined).length} Eyebecons` : "Direct: no beacons";
            if (!payloadDirect) { msg = "Broker offline - run .\\start_all.ps1 to get beacon data"; setStatus(msg, true); }
            else setStatus(msg, false);
          } else {
            setStatus("Loading Motorized GSE‚Ä¶");
            const response = await dataFetch(DATA_SOURCES.motorized_gse);
            if (!response.ok) throw new Error("fetch failed");
            payloadNavixy = await response.json();
            lastRows = (payloadNavixy.rows || []).filter((r) => !isIgnoredTracker(r));
            if (payloadNavixy.ble_positions && Object.keys(blePositions).length === 0) {
              Object.entries(payloadNavixy.ble_positions).forEach(([mac, pos]) => {
                blePositions[mac] = { lat: pos.lat, lng: pos.lng, lastTracker: pos.last_tracker_id, lastTrackerLabel: pos.last_tracker_label || "Unknown", lastUpdate: pos.last_update, isPaired: pos.is_paired };
              });
            }
            const combinedBle = { ...(payloadNavixy.ble_positions || {}) };
            mergeBeaconsFromRows(combinedBle, lastRows, forceRelink);
            const strictCombined = applyStrictBeaconInventory(combinedBle);
            sanitizeBeaconPositions(strictCombined, lastRows, {
              forceAllToNearestTracker: forceRelink
            });
            updateMarkers(lastRows);
            renderTable(lastRows);
            updateBeaconMarkersFromSQL(strictCombined, lastRows);
            setStatus(lastRows.length ? `Motorized GSE: ${lastRows.length} trackers` : "Motorized GSE: no trackers");
          }
          hasLoadedOnce = true;
        } catch (error) {
          console.error("Load data error:", error);
          const brokerMsg = "Broker offline - run .\\start_all.ps1 to get beacon data";
          if (currentDataSource === "direct" || currentDataSource === "both") setStatus(brokerMsg, true);
          else setStatus("Motorized GSE: data server unavailable", false);
        } finally {
          loadInProgress = false;
          if (forceRelink) setRelinkUi(false, "Done");
          if (forceRelink && relinkStatus) {
            setTimeout(() => {
              if (!loadInProgress) relinkStatus.textContent = "";
            }, 2500);
          }
        }
      }

      function startDataPolling() {
        loadData();
        setInterval(loadData, POLL_INTERVAL_MS);
      }
      if (typeof location !== "undefined" && location.hostname && location.hostname.indexOf("github.io") !== -1) {
        fetch("api-url.json?t=" + Date.now()).then(function(r){ return r.ok ? r.json() : {}; }).then(function(j){
          if (j && j.dataUrl) {
            window.__NAVIXY_DATA_SOURCES.motorized_gse = j.dataUrl;
            window.__NAVIXY_DATA_SOURCES.direct = j.dataUrl;
          }
          startDataPolling();
        }).catch(function(){ startDataPolling(); });
      } else {
        startDataPolling();
      }

      function syncXGpsCheckboxes(checked) {
        const opt = document.getElementById("toggleXGpsOptions");
        const leg = document.getElementById("toggleXGps");
        if (opt) opt.checked = !!checked;
        if (leg) leg.checked = !!checked;
      }
      function setXGpsVisible(visible) {
        showXGpsMarkers = !!visible;
        if (showXGpsMarkers && !map.hasLayer(xGpsLayer)) map.addLayer(xGpsLayer);
        if (!showXGpsMarkers && map.hasLayer(xGpsLayer)) map.removeLayer(xGpsLayer);
        syncXGpsCheckboxes(showXGpsMarkers);
        updateMarkers(lastRows);
      }
      document.getElementById("toggleXGpsOptions")?.addEventListener("change", function () { setXGpsVisible(this.checked); });
      document.getElementById("toggleXGps")?.addEventListener("change", function () { setXGpsVisible(this.checked); });
      relinkButton?.addEventListener("click", async function () {
        if (loadInProgress) return;
        clearBeaconRuntimeState();
        await loadData({ forceRelink: true });
      });
      relinkButtonTop?.addEventListener("click", async function () {
        if (loadInProgress) return;
        clearBeaconRuntimeState();
        await loadData({ forceRelink: true });
      });

      fetch("llbg_layers.geojson")
        .then((res) => res.json())
        .then((data) => {
          L.geoJSON(data, {
            pointToLayer: (feature, latlng) =>
              L.circleMarker(latlng, {
                radius: 7,
                color: "#7c3aed",
                fillColor: "#a855f7",
                fillOpacity: 0.9,
                weight: 2,
              }),
            onEachFeature: (feature, layer) => {
              const name = feature.properties?.name || "LLBG point";
              const source = feature.properties?.source || "";
              layer.bindTooltip(`${name}`, {
                direction: "top",
                permanent: true,
                opacity: 0.9,
                className: "llbg-label",
              });
              layer.bindPopup(`${name}<br/>${source}`);
            },
          }).addTo(llbgLayer);
        })
        .catch(() => {});

      // Removed LLBG chart overlays from the layer list.
    </script>
  </body>
</html>








