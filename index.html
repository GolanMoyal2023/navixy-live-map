<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Navixy Live Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .view-tabs {
        position: absolute;
        top: 72px;
        right: 12px;
        z-index: 1000;
        display: flex;
        gap: 6px;
      }

      .view-tab {
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 12px;
      }

      .view-tab.active {
        background: #2563eb;
        border-color: #1d4ed8;
      }

      .view-panel {
        display: none;
        height: 100%;
        width: 100%;
        position: relative;
      }

      .view-panel.active {
        display: block;
      }

      .table-view {
        height: 100%;
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        box-sizing: border-box;
      }

      .table-container {
        max-height: calc(100% - 16px);
        overflow: auto;
        border: 1px solid #1f2937;
        border-radius: 8px;
      }

      table.gse-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      table.gse-table th,
      table.gse-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #1f2937;
        text-align: left;
        vertical-align: top;
      }

      table.gse-table th {
        position: sticky;
        top: 0;
        background: #111827;
        z-index: 1;
      }

      .map-overlay {
        position: absolute;
        top: 12px;
        left: 56px;
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 12px;
        z-index: 1000;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #clearPopup {
        background: #1f2937;
        border: 1px solid #374151;
        color: #ffffff;
        padding: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }

      .map-overlay.debug {
        top: 48px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .map-overlay.legend {
        top: auto;
        bottom: 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .legend-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.4);
      }

      .hidden {
        display: none;
      }

      .llbg-label {
        background: rgba(255, 255, 255, 0.9);
        color: #4c1d95;
        border: 1px solid #c4b5fd;
        border-radius: 4px;
        padding: 1px 4px;
        font-size: 10px;
      }

      .leaflet-tooltip.gse-label {
        border-radius: 6px;
        color: #ffffff !important;
        font-weight: 700;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(0, 0, 0, 0.25) !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
      }
      .leaflet-tooltip.gse-status-available,
      .legend-swatch.gse-status-available { background: #00a651 !important; }
      .leaflet-tooltip.gse-status-in-use,
      .legend-swatch.gse-status-in-use { background: #f97316 !important; }
      .leaflet-tooltip.gse-status-moving,
      .legend-swatch.gse-status-moving { background: #1e88e5 !important; }
      .leaflet-tooltip.gse-status-idle,
      .legend-swatch.gse-status-idle { background: #e91e63 !important; }
      .leaflet-tooltip.gse-status-ignition,
      .legend-swatch.gse-status-ignition { background: #fdd835 !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-working,
      .legend-swatch.gse-status-working { background: #e53935 !important; }
      .leaflet-tooltip.gse-status-maintenance,
      .legend-swatch.gse-status-maintenance { background: #fb8c00 !important; }
      .leaflet-tooltip.gse-status-low-battery,
      .legend-swatch.gse-status-low-battery { background: #fbc02d !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-alert,
      .legend-swatch.gse-status-alert { background: #ef6c00 !important; }
    </style>
  </head>
  <body>
    <div class="view-tabs">
      <button class="view-tab active" data-view="map">Map</button>
      <button class="view-tab" data-view="table">Table</button>
    </div>
    <div id="mapView" class="view-panel active">
      <div id="map"></div>
      <div class="map-overlay">
        <span id="mapStatus">Loading...</span>
        <button id="clearPopup" type="button">Clear</button>
      </div>
      <div id="debugOverlay" class="map-overlay debug hidden">
        <span id="mapDebug">debug</span>
      </div>
      <div id="legendOverlay" class="map-overlay legend hidden">
        <div class="legend-row"><span class="legend-swatch gse-status-available"></span>Available</div>
        <div class="legend-row"><span class="legend-swatch gse-status-in-use"></span>In use</div>
        <div class="legend-row"><span class="legend-swatch gse-status-moving"></span>Moving</div>
        <div class="legend-row"><span class="legend-swatch gse-status-idle"></span>Idle</div>
        <div class="legend-row"><span class="legend-swatch gse-status-ignition"></span>Ignition on</div>
        <div class="legend-row"><span class="legend-swatch gse-status-working"></span>Working</div>
        <div class="legend-row"><span class="legend-swatch gse-status-maintenance"></span>Maintenance</div>
        <div class="legend-row"><span class="legend-swatch gse-status-low-battery"></span>Low battery</div>
        <div class="legend-row"><span class="legend-swatch gse-status-alert"></span>Alert</div>
      </div>
    </div>
    <div id="tableView" class="view-panel table-view">
      <div class="table-container">
        <table class="gse-table">
          <thead id="gseTableHead"></thead>
          <tbody id="gseTableBody"></tbody>
        </table>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const LIVE_API_URL = "https://outside-notebook-sheer-discounted.trycloudflare.com/data";
      const POLL_INTERVAL_MS = 2000;
      const map = L.map("map").setView([32.004, 34.876], 13);
      const layer = L.layerGroup().addTo(map);
      const llbgLayer = L.layerGroup();
      const debugLayer = L.layerGroup();
      const legendLayer = L.layerGroup();
      const chartLayers = {};

      const osmStreets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      const osmStandard = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      });
      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri",
        }
      );
      const baseLayers = {
        "OSM streets": osmStreets,
        OSM: osmStandard,
        "Satellite (Esri)": esriSat,
      };
      const overlayLayers = {
        "LLBG Gates/Zones": llbgLayer,
      };
      const layersControl = L.control
        .layers(
          baseLayers,
          overlayLayers,
          { position: "topright" }
        )
        .addTo(map);
      layersControl.addOverlay(debugLayer, "Debug");
      layersControl.addOverlay(legendLayer, "GSE Legend");

      const markers = {};
      let fitted = false;
      let activePopupId = null;
      let isRefreshing = false;
      let lastRows = [];
      const DASHBOARD_HEADERS = [
        "group_icon",
        "label",
        "imei",
        "group_name",
        "connection_status",
        "movement_status",
        "last_update",
        "nearest_gate",
        "nearest_gate_distance_m",
        "address",
        "best_nearby_zone",
        "best_nearby_distance_m",
        "lat",
        "lng",
        "odometer",
        "engine_hours",
        "Board voltage",
        "Board voltage__updated",
        "Fuel_level",
        "Fuel_level__updated",
        "GSE_Dashboard_warnings",
        "ac_moves_count",
        "brake_pressure_actual",
        "brake_pressure_set",
        "def_level",
        "eng_def_lamp",
        "eng_emc_stop_lamp",
        "eng_hest_lamp",
        "engine_hours_empty",
        "engine_hours_total",
        "engine_hours_with_ac",
        "engine_rpm",
        "engine_rpm__updated",
        "gotis_status",
        "next_service_hours",
        "pickup_state",
        "Gottis",
        "Moving",
        "Moving__updated",
        "Pup_State",
        "Engine_Temp",
        "Engine_Temp__updated",
        "Engine_O.P",
        "Engine_O.P__updated",
        "Fuel",
        "Fuel__updated",
        "BLE: ID",
        "EyeBecon",
        "Hardware key",
        "Hardware key__updated",
        "Ignition",
        "Ignition__updated",
        "Working__updated",
        "OBD: Absolute load value",
        "OBD: Control module voltage",
        "OBD: Coolant temperature",
        "OBD: Fuel",
        "OBD: Fuel consumption",
        "OBD: RPM",
        "OBD: Run time since engine start",
        "OBD: Speed",
        "OBD: Throttle",
        "OBD_ODD",
        "Errors",
        "OBD: Distance with MIL on",
        "OBD: Mileage after DTC reset",
        "VIN",
        "next_service_hours",
        "gse_score",
        "gps_signal",
        "gsm_signal",
        "inputs",
        "outputs",
        "fuel_sensors",
        "sensors_count",
      ];
      const iconCache = new Map();
      const lastPositions = new Map();
      const clearButton = document.getElementById("clearPopup");
      const debugOverlay = document.getElementById("debugOverlay");
      const legendOverlay = document.getElementById("legendOverlay");

      if (clearButton) {
        clearButton.addEventListener("click", () => {
          Object.values(markers).forEach((marker) => marker.closePopup());
          activePopupId = null;
        });
      }

      const viewTabs = document.querySelectorAll(".view-tab");
      const mapView = document.getElementById("mapView");
      const tableView = document.getElementById("tableView");
      viewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          viewTabs.forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          const view = tab.dataset.view;
          if (view === "table") {
            mapView.classList.remove("active");
            tableView.classList.add("active");
          } else {
            tableView.classList.remove("active");
            mapView.classList.add("active");
            map.invalidateSize();
          }
        });
      });

      map.on("overlayadd", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.remove("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.remove("hidden");
        }
      });
      map.on("overlayremove", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.add("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.add("hidden");
        }
      });

      function iconPathForRow(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        const name = `${label} ${group}`;
        if (label.includes("5032")) {
          return "Pictures/towing_barless_transparent.png";
        }
        if (label.includes("6074")) {
          return "Pictures/Champ70_transparent.png";
        }
        if (name.includes("towing") || name.includes("tow") || name.includes("??????")) {
          return "Pictures/TowBar.png";
        }
        if (name.includes("loader") || name.includes("??????")) {
          return "Pictures/Loader.png";
        }
        if (name.includes("acu") || name.includes("a/c")) {
          return "Pictures/TLD ACU.png";
        }
        if (name.includes("gpu")) {
          return "Pictures/TLD GPU.png";
        }
        if (name.includes("stair") || name.includes("stairs")) {
          return "Pictures/staires.png";
        }
        if (name.includes("manito")) {
          return "Pictures/Manito.png";
        }
        if (name.includes("tractor") || name.includes("tracktor") || name.includes("trac")) {
          return "Pictures/Tracktor.png";
        }
        return "Pictures/Aviation1.jpg";
      }

      function markerSizeForZoom(zoom) {
        const safeZoom = Number.isFinite(zoom) ? zoom : 13;
        const size = 14 + (safeZoom - 10) * 3;
        return Math.max(20, Math.min(56, Math.round(size)));
      }

      function markerIcon(path, size) {
        const key = `${path}|${size}`;
        if (!iconCache.has(key)) {
          iconCache.set(
            key,
            L.icon({
              iconUrl: encodeURI(path),
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2],
              popupAnchor: [0, -size / 2],
            })
          );
        }
        return iconCache.get(key);
      }

      function updateMarkerIcons() {
        const size = markerSizeForZoom(map.getZoom());
        Object.values(markers).forEach((marker) => {
          const iconPath = marker.options.iconPath || "Pictures/Aviation1.jpg";
          marker.setIcon(markerIcon(iconPath, size));
        });
      }

      map.on("zoomend", updateMarkerIcons);

      const LOW_FUEL_THRESHOLD = 20;
      const LOW_BATTERY_THRESHOLD = 24;
      const MOVE_DISTANCE_METERS = 10;

      function parseNumber(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const num = Number(String(value).replace(/[^\d.-]/g, ""));
        return Number.isFinite(num) ? num : null;
      }

      function parseBoolean(value) {
        if (value === null || value === undefined) {
          return false;
        }
        if (typeof value === "boolean") {
          return value;
        }
        const text = String(value).trim().toLowerCase();
        return text === "on" || text === "true" || text === "1" || text === "yes" || text === "active";
      }

      function distanceMeters(lat1, lon1, lat2, lon2) {
        const toRad = (deg) => (deg * Math.PI) / 180;
        const r = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return r * c;
      }

      function updateDistance(id, lat, lng) {
        const prev = lastPositions.get(id);
        lastPositions.set(id, { lat, lng });
        if (!prev) {
          return 0;
        }
        return distanceMeters(prev.lat, prev.lng, lat, lng);
      }

      function isMoving(row) {
        const status = String(row.movement_status || "").toLowerCase();
        if (status.includes("moving")) {
          return true;
        }
        const speed = parseNumber(row.speed ?? row.Speed);
        return speed !== null ? speed > 0.5 : false;
      }

      function isIgnitionOn(row) {
        const ignition =
          row.Ignition ??
          row.ignition ??
          row["Ignition"] ??
          row["Ignition status"] ??
          row["ignition_status"] ??
          row.input1 ??
          row["input1"] ??
          row["Input1"] ??
          row["Input 1"];
        if (parseBoolean(ignition)) {
          return true;
        }
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        return rpm !== null ? rpm > 0 : false;
      }

      function isLoader(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        return label.includes("loader") || group.includes("loader") || label.includes("6074");
      }

      function isWorking(row, moving) {
        if (moving) {
          return false;
        }
        if (isIgnitionOn(row)) {
          return true;
        }
        const workingFlag =
          parseBoolean(row.Working) ||
          parseBoolean(row.working) ||
          parseBoolean(row["Working-Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer_Extract"]);
        const oilPressure = parseNumber(row["Engine_O.P"] ?? row.Engine_O_P ?? row.Engine_OP);
        if (workingFlag) {
          return true;
        }
        if (isLoader(row) && oilPressure !== null) {
          return oilPressure > 2;
        }
        return false;
      }

      function isAlert(row) {
        const fuel = parseNumber(row.Fuel_level ?? row.Fuel ?? row["Fuel level"]);
        const battery = parseNumber(
          row["Battery level"] ??
            row.battery_level ??
            row.Voltage ??
            row.voltage ??
            row["Board voltage"]
        );
        const lowFuel = fuel !== null ? fuel < LOW_FUEL_THRESHOLD : false;
        const lowBattery = battery !== null ? battery < LOW_BATTERY_THRESHOLD : false;
        const nextService = parseNumber(row.next_service_hours ?? row["Next Service"]);
        const alertFlag =
          parseBoolean(row.Alert) ||
          parseBoolean(row.alert) ||
          parseBoolean(row["Repair requested"]);
        const nextServiceDue = nextService !== null ? nextService <= 0 : false;
        return lowFuel || nextServiceDue || alertFlag || lowBattery;
      }

      function statusLabel(row) {
        return row.movement_status || row.connection_status || "unknown";
      }

      function statusClass(row, moving, distanceMetersValue) {
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        const maintenance =
          parseBoolean(row["Maintenance zone"]) ||
          parseBoolean(row.maintenance_zone) ||
          parseBoolean(row["In maintenance"]);
        const navixyStatus = String(row.movement_status || row.connection_status || "")
          .toLowerCase()
          .trim();

        if (isAlert(row)) {
          return "gse-status-alert";
        }
        if (maintenance) {
          return "gse-status-maintenance";
        }
        if (parseNumber(row.Voltage ?? row.voltage) !== null) {
          const voltage = parseNumber(row.Voltage ?? row.voltage);
          if (voltage !== null && voltage < LOW_BATTERY_THRESHOLD) {
            return "gse-status-low-battery";
          }
        }
        if (isWorking(row, moving)) {
          return "gse-status-working";
        }
        if (navixyStatus.includes("moving")) {
          return "gse-status-moving";
        }
        if (navixyStatus.includes("idle")) {
          return "gse-status-idle";
        }
        if (
          navixyStatus.includes("standstill") ||
          navixyStatus.includes("park") ||
          navixyStatus.includes("stopp")
        ) {
          return "gse-status-available";
        }
        if (navixyStatus.includes("offline")) {
          return "gse-status-stop";
        }
        if (moving || distanceMetersValue > MOVE_DISTANCE_METERS) {
          return "gse-status-moving";
        }
        if (rpm !== null && rpm !== 0) {
          return "gse-status-in-use";
        }
        if (rpm !== null && rpm < 2000 && distanceMetersValue <= MOVE_DISTANCE_METERS) {
          return "gse-status-idle";
        }
        if (isIgnitionOn(row)) {
          return "gse-status-ignition";
        }
        return "gse-status-available";
      }

      function updateTooltip(marker, text, className) {
        if (!marker.getTooltip()) {
          marker.bindTooltip(text, {
            permanent: true,
            direction: "top",
            offset: [0, -12],
            className: `gse-label ${className}`,
          });
          return;
        }
        marker.setTooltipContent(text);
        marker.getTooltip().options.className = `gse-label ${className}`;
        if (marker.getTooltip()._container) {
          marker.getTooltip()._container.className = `leaflet-tooltip gse-label ${className}`;
        }
      }

      function formatLabel(row) {
        const label = row.label || row.tracker_id || "";
        const match = String(label).match(/(\d{4})/);
        return match ? match[1] : String(label);
      }

      function formatStatus(row) {
        return row.movement_status || row.connection_status || "--";
      }

      function formatSensor(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("Fuel", row.Fuel_level ?? row.Fuel);
        add("Voltage", row["Board voltage"] ?? row.Voltage ?? row.voltage);
        add("EngTemp", row.Engine_Temp ?? row.engine_temperature);
        add("EngOP", row["Engine_O.P"]);
        add("RPM", row.engine_rpm);
        return parts.length ? parts.join(" | ") : "--";
      }

      function formatBeacon(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("BLE", row["BLE: ID"]);
        add("EyeBecon", row.EyeBecon);
        add("Key", row["Hardware key"]);
        return parts.length ? parts.join(" | ") : "--";
      }

      function renderTable(rows) {
        const head = document.getElementById("gseTableHead");
        const body = document.getElementById("gseTableBody");
        if (!head || !body) {
          return;
        }
        const headers = DASHBOARD_HEADERS.flatMap((h) => (h === "label" ? ["label", "label_updated"] : [h]));
        head.innerHTML = `<tr>${headers.map((h) => `<th>${h}</th>`).join("")}</tr>`;
        body.innerHTML = rows
          .map((row) => {
            const cells = headers.map((h) => {
              if (h === "label") {
                return formatLabel(row);
              }
              if (h === "label_updated") {
                return row.last_update || row.gps_updated || "--";
              }
              if (h.endsWith("__updated")) {
                return row[h] ?? "--";
              }
              return row[h] ?? "--";
            })
              .map((value) => `<td>${value}</td>`)
              .join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");
      }

      function popupHtml(row) {
        const label = row.label || row.tracker_id || "tracker";
        const lat = row.lat;
        const lng = row.lng;
        const status = statusLabel(row);
        const base = `<strong>${label}</strong><br/>${status}<br/>${lat}, ${lng}`;
        const extra = [];
        const sensorUpdated = (() => {
          const candidates = Object.keys(row || {})
            .filter((key) => key.endsWith("__updated"))
            .map((key) => row[key])
            .filter(Boolean);
          let latestRaw = null;
          let latestTime = null;
          candidates.forEach((value) => {
            const parsed = Date.parse(value);
            if (Number.isNaN(parsed)) {
              if (!latestRaw) {
                latestRaw = value;
              }
              return;
            }
            if (latestTime === null || parsed > latestTime) {
              latestTime = parsed;
              latestRaw = value;
            }
          });
          return latestRaw;
        })();
        const ignition = isIgnitionOn(row) ? "on" : "off";
        const ignitionUpdated = row["Ignition__updated"] ?? row["ignition__updated"];
        extra.push(`Ignition: ${ignition}${ignitionUpdated ? ` (updated ${ignitionUpdated})` : ""}`);
        const statusUpdated = row.last_update || row.gps_updated;
        if (statusUpdated) {
          extra.push(`Last status report: ${statusUpdated}`);
        }
        if (sensorUpdated) {
          extra.push(`Last sensor report: ${sensorUpdated}`);
        }
        if (label.includes("6074")) {
          const tempUpdated = row["Engine_Temp__updated"];
          const opUpdated = row["Engine_O.P__updated"];
          const fuelUpdated = row["Fuel__updated"];
          extra.push(
            `Engine_Temp: ${row.Engine_Temp ?? "--"}${tempUpdated ? ` (updated ${tempUpdated})` : ""}`
          );
          extra.push(
            `Engine_O.P: ${row["Engine_O.P"] ?? "--"}${opUpdated ? ` (updated ${opUpdated})` : ""}`
          );
          extra.push(`Fuel: ${row.Fuel ?? "--"}${fuelUpdated ? ` (updated ${fuelUpdated})` : ""}`);
          extra.push(`Engine Hours: ${row.engine_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        if (label.includes("5032")) {
          const fuelLevelUpdated = row["Fuel_level__updated"];
          const rpmUpdated = row["engine_rpm__updated"];
          extra.push(
            `Fuel_level: ${row.Fuel_level ?? "--"}${fuelLevelUpdated ? ` (updated ${fuelLevelUpdated})` : ""}`
          );
          extra.push(
            `Engine RPM: ${row.engine_rpm ?? "--"}${rpmUpdated ? ` (updated ${rpmUpdated})` : ""}`
          );
          extra.push(`Engine Hours: ${row.engine_hours_total ?? row.engine_hours ?? "--"}`);
          extra.push(`Next Service: ${row.next_service_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        return `${base}${extra.length ? "<br/>" + extra.join("<br/>") : ""}`;
      }

      function updateMarkers(rows) {
        isRefreshing = true;
        if (!map.hasLayer(layer)) {
          layer.addTo(map);
        }
        const bounds = [];
        const seen = new Set();
        rows.forEach((row) => {
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            return;
          }
          const label = row.label || row.tracker_id || "tracker";
          const shortMatch = String(label).match(/(\d{4})/);
          const shortLabel = shortMatch ? shortMatch[1] : label;
          const id = String(row.tracker_id || label);
          const iconPath = iconPathForRow(row);
          const size = markerSizeForZoom(map.getZoom());
          const distanceMetersValue = updateDistance(id, lat, lng);
          const moving = isMoving(row) || distanceMetersValue > MOVE_DISTANCE_METERS;
          const labelClass = statusClass(row, moving, distanceMetersValue);
          let marker = markers[id];
          if (!marker) {
            marker = L.marker([lat, lng], {
              icon: markerIcon(iconPath, size),
              iconPath,
            })
              .bindPopup(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
            marker.off("click", marker._openPopup);
            marker.on("click", () => {
              marker.openPopup();
              activePopupId = id;
            });
            marker.on("popupclose", () => {
              if (isRefreshing) {
                return;
              }
              if (activePopupId === id) {
                activePopupId = null;
              }
            });
            markers[id] = marker;
            marker.addTo(layer);
          } else {
            marker.setLatLng([lat, lng]);
            marker.setIcon(markerIcon(iconPath, size));
            marker.options.iconPath = iconPath;
            marker.setPopupContent(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
          }
          seen.add(id);
          if (!String(label).toLowerCase().includes("skoda")) {
            bounds.push([lat, lng]);
          }
        });
        Object.keys(markers).forEach((key) => {
          if (!seen.has(key)) {
            const marker = markers[key];
            layer.removeLayer(marker);
            delete markers[key];
            if (activePopupId === key) {
              activePopupId = null;
            }
          }
        });

        const statusEl = document.getElementById("mapStatus");
        const debugEl = document.getElementById("mapDebug");
        if (statusEl) {
          statusEl.textContent = `Trackers: ${rows.length} | Markers: ${bounds.length}`;
        }
        if (debugEl) {
          const first = rows.find((row) => Number.isFinite(Number(row.lat)) && Number.isFinite(Number(row.lng)));
          const zoom = map.getZoom();
          debugEl.textContent = first
            ? `| zoom ${zoom} | ${Number(first.lat).toFixed(5)}, ${Number(first.lng).toFixed(5)}`
            : `| zoom ${zoom} | no lat/lng`;
        }

        if (!fitted) {
          if (bounds.length === 1) {
            map.setView(bounds[0], 15);
          } else {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          fitted = true;
        }
        if (activePopupId && markers[activePopupId]) {
          markers[activePopupId].openPopup();
        }
        isRefreshing = false;
      }

      async function loadData() {
        try {
          const response = await fetch(LIVE_API_URL);
          if (!response.ok) {
            throw new Error("fetch failed");
          }
          const payload = await response.json();
          lastRows = payload.rows || [];
          updateMarkers(lastRows);
          renderTable(lastRows);
        } catch (error) {
          const statusEl = document.getElementById("mapStatus");
          if (statusEl) {
            statusEl.textContent = "Failed to load live data.";
          }
        }
      }

      loadData();
      setInterval(loadData, POLL_INTERVAL_MS);

      fetch("llbg_layers.geojson")
        .then((res) => res.json())
        .then((data) => {
          L.geoJSON(data, {
            pointToLayer: (feature, latlng) =>
              L.circleMarker(latlng, {
                radius: 7,
                color: "#7c3aed",
                fillColor: "#a855f7",
                fillOpacity: 0.9,
                weight: 2,
              }),
            onEachFeature: (feature, layer) => {
              const name = feature.properties?.name || "LLBG point";
              const source = feature.properties?.source || "";
              layer.bindTooltip(`${name}`, {
                direction: "top",
                permanent: true,
                opacity: 0.9,
                className: "llbg-label",
              });
              layer.bindPopup(`${name}<br/>${source}`);
            },
          }).addTo(llbgLayer);
        })
        .catch(() => {});

      // Removed LLBG chart overlays from the layer list.
    </script>
  </body>
</html>
-->
<!--
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Navixy Live Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .view-tabs {
        position: absolute;
        top: 72px;
        right: 12px;
        z-index: 1000;
        display: flex;
        gap: 6px;
      }

      .view-tab {
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 12px;
      }

      .view-tab.active {
        background: #2563eb;
        border-color: #1d4ed8;
      }

      .view-panel {
        display: none;
        height: 100%;
        width: 100%;
        position: relative;
      }

      .view-panel.active {
        display: block;
      }

      .table-view {
        height: 100%;
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        box-sizing: border-box;
      }

      .table-container {
        max-height: calc(100% - 16px);
        overflow: auto;
        border: 1px solid #1f2937;
        border-radius: 8px;
      }

      table.gse-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      table.gse-table th,
      table.gse-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #1f2937;
        text-align: left;
        vertical-align: top;
      }

      table.gse-table th {
        position: sticky;
        top: 0;
        background: #111827;
        z-index: 1;
      }

      .map-overlay {
        position: absolute;
        top: 12px;
        left: 56px;
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 12px;
        z-index: 1000;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #clearPopup {
        background: #1f2937;
        border: 1px solid #374151;
        color: #ffffff;
        padding: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }

      .map-overlay.debug {
        top: 48px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .map-overlay.legend {
        top: auto;
        bottom: 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .legend-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.4);
      }

      .hidden {
        display: none;
      }

      .llbg-label {
        background: rgba(255, 255, 255, 0.9);
        color: #4c1d95;
        border: 1px solid #c4b5fd;
        border-radius: 4px;
        padding: 1px 4px;
        font-size: 10px;
      }

      .leaflet-tooltip.gse-label {
        border-radius: 6px;
        color: #ffffff !important;
        font-weight: 700;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(0, 0, 0, 0.25) !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
      }
      .leaflet-tooltip.gse-status-available,
      .legend-swatch.gse-status-available { background: #00a651 !important; }
      .leaflet-tooltip.gse-status-in-use,
      .legend-swatch.gse-status-in-use { background: #f97316 !important; }
      .leaflet-tooltip.gse-status-moving,
      .legend-swatch.gse-status-moving { background: #1e88e5 !important; }
      .leaflet-tooltip.gse-status-idle,
      .legend-swatch.gse-status-idle { background: #e91e63 !important; }
      .leaflet-tooltip.gse-status-ignition,
      .legend-swatch.gse-status-ignition { background: #fdd835 !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-working,
      .legend-swatch.gse-status-working { background: #e53935 !important; }
      .leaflet-tooltip.gse-status-maintenance,
      .legend-swatch.gse-status-maintenance { background: #fb8c00 !important; }
      .leaflet-tooltip.gse-status-low-battery,
      .legend-swatch.gse-status-low-battery { background: #fbc02d !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-alert,
      .legend-swatch.gse-status-alert { background: #ef6c00 !important; }
    </style>
  </head>
  <body>
    <div class="view-tabs">
      <button class="view-tab active" data-view="map">Map</button>
      <button class="view-tab" data-view="table">Table</button>
    </div>
    <div id="mapView" class="view-panel active">
      <div id="map"></div>
      <div class="map-overlay">
        <span id="mapStatus">Loading...</span>
        <button id="clearPopup" type="button">Clear</button>
      </div>
      <div id="debugOverlay" class="map-overlay debug hidden">
        <span id="mapDebug">debug</span>
      </div>
      <div id="legendOverlay" class="map-overlay legend hidden">
        <div class="legend-row"><span class="legend-swatch gse-status-available"></span>Available</div>
        <div class="legend-row"><span class="legend-swatch gse-status-in-use"></span>In use</div>
        <div class="legend-row"><span class="legend-swatch gse-status-moving"></span>Moving</div>
        <div class="legend-row"><span class="legend-swatch gse-status-idle"></span>Idle</div>
        <div class="legend-row"><span class="legend-swatch gse-status-ignition"></span>Ignition on</div>
        <div class="legend-row"><span class="legend-swatch gse-status-working"></span>Working</div>
        <div class="legend-row"><span class="legend-swatch gse-status-maintenance"></span>Maintenance</div>
        <div class="legend-row"><span class="legend-swatch gse-status-low-battery"></span>Low battery</div>
        <div class="legend-row"><span class="legend-swatch gse-status-alert"></span>Alert</div>
      </div>
    </div>
    <div id="tableView" class="view-panel table-view">
      <div class="table-container">
        <table class="gse-table">
          <thead id="gseTableHead"></thead>
          <tbody id="gseTableBody"></tbody>
        </table>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const LIVE_API_URL = "https://outside-notebook-sheer-discounted.trycloudflare.com/data";
      const POLL_INTERVAL_MS = 2000;
      const map = L.map("map").setView([32.004, 34.876], 13);
      const layer = L.layerGroup().addTo(map);
      const llbgLayer = L.layerGroup();
      const debugLayer = L.layerGroup();
      const legendLayer = L.layerGroup();
      const chartLayers = {};

      const osmStreets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      const osmStandard = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      });
      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri",
        }
      );
      const baseLayers = {
        "OSM streets": osmStreets,
        OSM: osmStandard,
        "Satellite (Esri)": esriSat,
      };
      const overlayLayers = {
        "LLBG Gates/Zones": llbgLayer,
      };
      const layersControl = L.control
        .layers(
          baseLayers,
          overlayLayers,
          { position: "topright" }
        )
        .addTo(map);
      layersControl.addOverlay(debugLayer, "Debug");
      layersControl.addOverlay(legendLayer, "GSE Legend");

      const markers = {};
      let fitted = false;
      let activePopupId = null;
      let isRefreshing = false;
      let lastRows = [];
      const DASHBOARD_HEADERS = [
        "group_icon",
        "label",
        "imei",
        "group_name",
        "connection_status",
        "movement_status",
        "last_update",
        "nearest_gate",
        "nearest_gate_distance_m",
        "address",
        "best_nearby_zone",
        "best_nearby_distance_m",
        "lat",
        "lng",
        "odometer",
        "engine_hours",
        "Board voltage",
        "Board voltage__updated",
        "Fuel_level",
        "Fuel_level__updated",
        "GSE_Dashboard_warnings",
        "ac_moves_count",
        "brake_pressure_actual",
        "brake_pressure_set",
        "def_level",
        "eng_def_lamp",
        "eng_emc_stop_lamp",
        "eng_hest_lamp",
        "engine_hours_empty",
        "engine_hours_total",
        "engine_hours_with_ac",
        "engine_rpm",
        "engine_rpm__updated",
        "gotis_status",
        "next_service_hours",
        "pickup_state",
        "Gottis",
        "Moving",
        "Moving__updated",
        "Pup_State",
        "Engine_Temp",
        "Engine_Temp__updated",
        "Engine_O.P",
        "Engine_O.P__updated",
        "Fuel",
        "Fuel__updated",
        "BLE: ID",
        "EyeBecon",
        "Hardware key",
        "Hardware key__updated",
        "Ignition",
        "Ignition__updated",
        "Working__updated",
        "OBD: Absolute load value",
        "OBD: Control module voltage",
        "OBD: Coolant temperature",
        "OBD: Fuel",
        "OBD: Fuel consumption",
        "OBD: RPM",
        "OBD: Run time since engine start",
        "OBD: Speed",
        "OBD: Throttle",
        "OBD_ODD",
        "Errors",
        "OBD: Distance with MIL on",
        "OBD: Mileage after DTC reset",
        "VIN",
        "next_service_hours",
        "gse_score",
        "gps_signal",
        "gsm_signal",
        "inputs",
        "outputs",
        "fuel_sensors",
        "sensors_count",
      ];
      const iconCache = new Map();
      const lastPositions = new Map();
      const clearButton = document.getElementById("clearPopup");
      const debugOverlay = document.getElementById("debugOverlay");
      const legendOverlay = document.getElementById("legendOverlay");

      if (clearButton) {
        clearButton.addEventListener("click", () => {
          Object.values(markers).forEach((marker) => marker.closePopup());
          activePopupId = null;
        });
      }

      const viewTabs = document.querySelectorAll(".view-tab");
      const mapView = document.getElementById("mapView");
      const tableView = document.getElementById("tableView");
      viewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          viewTabs.forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          const view = tab.dataset.view;
          if (view === "table") {
            mapView.classList.remove("active");
            tableView.classList.add("active");
          } else {
            tableView.classList.remove("active");
            mapView.classList.add("active");
            map.invalidateSize();
          }
        });
      });

      map.on("overlayadd", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.remove("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.remove("hidden");
        }
      });
      map.on("overlayremove", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.add("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.add("hidden");
        }
      });

      function iconPathForRow(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        const name = `${label} ${group}`;
        if (label.includes("5032")) {
          return "Pictures/towing_barless_transparent.png";
        }
        if (label.includes("6074")) {
          return "Pictures/Champ70_transparent.png";
        }
        if (name.includes("towing") || name.includes("tow") || name.includes("??????")) {
          return "Pictures/TowBar.png";
        }
        if (name.includes("loader") || name.includes("??????")) {
          return "Pictures/Loader.png";
        }
        if (name.includes("acu") || name.includes("a/c")) {
          return "Pictures/TLD ACU.png";
        }
        if (name.includes("gpu")) {
          return "Pictures/TLD GPU.png";
        }
        if (name.includes("stair") || name.includes("stairs")) {
          return "Pictures/staires.png";
        }
        if (name.includes("manito")) {
          return "Pictures/Manito.png";
        }
        if (name.includes("tractor") || name.includes("tracktor") || name.includes("trac")) {
          return "Pictures/Tracktor.png";
        }
        return "Pictures/Aviation1.jpg";
      }

      function markerSizeForZoom(zoom) {
        const safeZoom = Number.isFinite(zoom) ? zoom : 13;
        const size = 14 + (safeZoom - 10) * 3;
        return Math.max(20, Math.min(56, Math.round(size)));
      }

      function markerIcon(path, size) {
        const key = `${path}|${size}`;
        if (!iconCache.has(key)) {
          iconCache.set(
            key,
            L.icon({
              iconUrl: encodeURI(path),
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2],
              popupAnchor: [0, -size / 2],
            })
          );
        }
        return iconCache.get(key);
      }

      function updateMarkerIcons() {
        const size = markerSizeForZoom(map.getZoom());
        Object.values(markers).forEach((marker) => {
          const iconPath = marker.options.iconPath || "Pictures/Aviation1.jpg";
          marker.setIcon(markerIcon(iconPath, size));
        });
      }

      map.on("zoomend", updateMarkerIcons);

      const LOW_FUEL_THRESHOLD = 20;
      const LOW_BATTERY_THRESHOLD = 24;
      const MOVE_DISTANCE_METERS = 10;

      function parseNumber(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const num = Number(String(value).replace(/[^\d.-]/g, ""));
        return Number.isFinite(num) ? num : null;
      }

      function parseBoolean(value) {
        if (value === null || value === undefined) {
          return false;
        }
        if (typeof value === "boolean") {
          return value;
        }
        const text = String(value).trim().toLowerCase();
        return text === "on" || text === "true" || text === "1" || text === "yes" || text === "active";
      }

      function distanceMeters(lat1, lon1, lat2, lon2) {
        const toRad = (deg) => (deg * Math.PI) / 180;
        const r = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return r * c;
      }

      function updateDistance(id, lat, lng) {
        const prev = lastPositions.get(id);
        lastPositions.set(id, { lat, lng });
        if (!prev) {
          return 0;
        }
        return distanceMeters(prev.lat, prev.lng, lat, lng);
      }

      function isMoving(row) {
        const status = String(row.movement_status || "").toLowerCase();
        if (status.includes("moving")) {
          return true;
        }
        const speed = parseNumber(row.speed ?? row.Speed);
        return speed !== null ? speed > 0.5 : false;
      }

      function isIgnitionOn(row) {
        const ignition =
          row.Ignition ??
          row.ignition ??
          row["Ignition"] ??
          row["Ignition status"] ??
          row["ignition_status"] ??
          row.input1 ??
          row["input1"] ??
          row["Input1"] ??
          row["Input 1"];
        if (parseBoolean(ignition)) {
          return true;
        }
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        return rpm !== null ? rpm > 0 : false;
      }

      function isLoader(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        return label.includes("loader") || group.includes("loader") || label.includes("6074");
      }

      function isWorking(row, moving) {
        if (moving) {
          return false;
        }
        if (isIgnitionOn(row)) {
          return true;
        }
        const workingFlag =
          parseBoolean(row.Working) ||
          parseBoolean(row.working) ||
          parseBoolean(row["Working-Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer_Extract"]);
        const oilPressure = parseNumber(row["Engine_O.P"] ?? row.Engine_O_P ?? row.Engine_OP);
        if (workingFlag) {
          return true;
        }
        if (isLoader(row) && oilPressure !== null) {
          return oilPressure > 2;
        }
        return false;
      }

      function isAlert(row) {
        const fuel = parseNumber(row.Fuel_level ?? row.Fuel ?? row["Fuel level"]);
        const battery = parseNumber(
          row["Battery level"] ??
            row.battery_level ??
            row.Voltage ??
            row.voltage ??
            row["Board voltage"]
        );
        const lowFuel = fuel !== null ? fuel < LOW_FUEL_THRESHOLD : false;
        const lowBattery = battery !== null ? battery < LOW_BATTERY_THRESHOLD : false;
        const nextService = parseNumber(row.next_service_hours ?? row["Next Service"]);
        const alertFlag =
          parseBoolean(row.Alert) ||
          parseBoolean(row.alert) ||
          parseBoolean(row["Repair requested"]);
        const nextServiceDue = nextService !== null ? nextService <= 0 : false;
        return lowFuel || nextServiceDue || alertFlag || lowBattery;
      }

      function statusLabel(row) {
        return row.movement_status || row.connection_status || "unknown";
      }

      function statusClass(row, moving, distanceMetersValue) {
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        const maintenance =
          parseBoolean(row["Maintenance zone"]) ||
          parseBoolean(row.maintenance_zone) ||
          parseBoolean(row["In maintenance"]);
        const navixyStatus = String(row.movement_status || row.connection_status || "")
          .toLowerCase()
          .trim();

        if (isAlert(row)) {
          return "gse-status-alert";
        }
        if (maintenance) {
          return "gse-status-maintenance";
        }
        if (parseNumber(row.Voltage ?? row.voltage) !== null) {
          const voltage = parseNumber(row.Voltage ?? row.voltage);
          if (voltage !== null && voltage < LOW_BATTERY_THRESHOLD) {
            return "gse-status-low-battery";
          }
        }
        if (isWorking(row, moving)) {
          return "gse-status-working";
        }
        if (navixyStatus.includes("moving")) {
          return "gse-status-moving";
        }
        if (navixyStatus.includes("idle")) {
          return "gse-status-idle";
        }
        if (
          navixyStatus.includes("standstill") ||
          navixyStatus.includes("park") ||
          navixyStatus.includes("stopp")
        ) {
          return "gse-status-available";
        }
        if (navixyStatus.includes("offline")) {
          return "gse-status-stop";
        }
        if (moving || distanceMetersValue > MOVE_DISTANCE_METERS) {
          return "gse-status-moving";
        }
        if (rpm !== null && rpm !== 0) {
          return "gse-status-in-use";
        }
        if (rpm !== null && rpm < 2000 && distanceMetersValue <= MOVE_DISTANCE_METERS) {
          return "gse-status-idle";
        }
        if (isIgnitionOn(row)) {
          return "gse-status-ignition";
        }
        return "gse-status-available";
      }

      function updateTooltip(marker, text, className) {
        if (!marker.getTooltip()) {
          marker.bindTooltip(text, {
            permanent: true,
            direction: "top",
            offset: [0, -12],
            className: `gse-label ${className}`,
          });
          return;
        }
        marker.setTooltipContent(text);
        marker.getTooltip().options.className = `gse-label ${className}`;
        if (marker.getTooltip()._container) {
          marker.getTooltip()._container.className = `leaflet-tooltip gse-label ${className}`;
        }
      }

      function formatLabel(row) {
        const label = row.label || row.tracker_id || "";
        const match = String(label).match(/(\d{4})/);
        return match ? match[1] : String(label);
      }

      function formatStatus(row) {
        return row.movement_status || row.connection_status || "--";
      }

      function formatSensor(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("Fuel", row.Fuel_level ?? row.Fuel);
        add("Voltage", row["Board voltage"] ?? row.Voltage ?? row.voltage);
        add("EngTemp", row.Engine_Temp ?? row.engine_temperature);
        add("EngOP", row["Engine_O.P"]);
        add("RPM", row.engine_rpm);
        return parts.length ? parts.join(" | ") : "--";
      }

      function formatBeacon(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("BLE", row["BLE: ID"]);
        add("EyeBecon", row.EyeBecon);
        add("Key", row["Hardware key"]);
        return parts.length ? parts.join(" | ") : "--";
      }

      function renderTable(rows) {
        const head = document.getElementById("gseTableHead");
        const body = document.getElementById("gseTableBody");
        if (!head || !body) {
          return;
        }
        const headers = DASHBOARD_HEADERS.flatMap((h) => (h === "label" ? ["label", "label_updated"] : [h]));
        head.innerHTML = `<tr>${headers.map((h) => `<th>${h}</th>`).join("")}</tr>`;
        body.innerHTML = rows
          .map((row) => {
            const cells = headers.map((h) => {
              if (h === "label") {
                return formatLabel(row);
              }
              if (h === "label_updated") {
                return row.last_update || row.gps_updated || "--";
              }
              if (h.endsWith("__updated")) {
                return row[h] ?? "--";
              }
              return row[h] ?? "--";
            })
              .map((value) => `<td>${value}</td>`)
              .join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");
      }

      function popupHtml(row) {
        const label = row.label || row.tracker_id || "tracker";
        const lat = row.lat;
        const lng = row.lng;
        const status = statusLabel(row);
        const base = `<strong>${label}</strong><br/>${status}<br/>${lat}, ${lng}`;
        const extra = [];
        const sensorUpdated = (() => {
          const candidates = Object.keys(row || {})
            .filter((key) => key.endsWith("__updated"))
            .map((key) => row[key])
            .filter(Boolean);
          let latestRaw = null;
          let latestTime = null;
          candidates.forEach((value) => {
            const parsed = Date.parse(value);
            if (Number.isNaN(parsed)) {
              if (!latestRaw) {
                latestRaw = value;
              }
              return;
            }
            if (latestTime === null || parsed > latestTime) {
              latestTime = parsed;
              latestRaw = value;
            }
          });
          return latestRaw;
        })();
        const ignition = isIgnitionOn(row) ? "on" : "off";
        const ignitionUpdated = row["Ignition__updated"] ?? row["ignition__updated"];
        extra.push(`Ignition: ${ignition}${ignitionUpdated ? ` (updated ${ignitionUpdated})` : ""}`);
        const statusUpdated = row.last_update || row.gps_updated;
        if (statusUpdated) {
          extra.push(`Last status report: ${statusUpdated}`);
        }
        if (sensorUpdated) {
          extra.push(`Last sensor report: ${sensorUpdated}`);
        }
        if (label.includes("6074")) {
          const tempUpdated = row["Engine_Temp__updated"];
          const opUpdated = row["Engine_O.P__updated"];
          const fuelUpdated = row["Fuel__updated"];
          extra.push(
            `Engine_Temp: ${row.Engine_Temp ?? "--"}${tempUpdated ? ` (updated ${tempUpdated})` : ""}`
          );
          extra.push(
            `Engine_O.P: ${row["Engine_O.P"] ?? "--"}${opUpdated ? ` (updated ${opUpdated})` : ""}`
          );
          extra.push(`Fuel: ${row.Fuel ?? "--"}${fuelUpdated ? ` (updated ${fuelUpdated})` : ""}`);
          extra.push(`Engine Hours: ${row.engine_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        if (label.includes("5032")) {
          const fuelLevelUpdated = row["Fuel_level__updated"];
          const rpmUpdated = row["engine_rpm__updated"];
          extra.push(
            `Fuel_level: ${row.Fuel_level ?? "--"}${fuelLevelUpdated ? ` (updated ${fuelLevelUpdated})` : ""}`
          );
          extra.push(
            `Engine RPM: ${row.engine_rpm ?? "--"}${rpmUpdated ? ` (updated ${rpmUpdated})` : ""}`
          );
          extra.push(`Engine Hours: ${row.engine_hours_total ?? row.engine_hours ?? "--"}`);
          extra.push(`Next Service: ${row.next_service_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        return `${base}${extra.length ? "<br/>" + extra.join("<br/>") : ""}`;
      }

      function updateMarkers(rows) {
        isRefreshing = true;
        if (!map.hasLayer(layer)) {
          layer.addTo(map);
        }
        const bounds = [];
        const seen = new Set();
        rows.forEach((row) => {
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            return;
          }
          const label = row.label || row.tracker_id || "tracker";
          const shortMatch = String(label).match(/(\d{4})/);
          const shortLabel = shortMatch ? shortMatch[1] : label;
          const id = String(row.tracker_id || label);
          const iconPath = iconPathForRow(row);
          const size = markerSizeForZoom(map.getZoom());
          const distanceMetersValue = updateDistance(id, lat, lng);
          const moving = isMoving(row) || distanceMetersValue > MOVE_DISTANCE_METERS;
          const labelClass = statusClass(row, moving, distanceMetersValue);
          let marker = markers[id];
          if (!marker) {
            marker = L.marker([lat, lng], {
              icon: markerIcon(iconPath, size),
              iconPath,
            })
              .bindPopup(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
            marker.off("click", marker._openPopup);
            marker.on("click", () => {
              marker.openPopup();
              activePopupId = id;
            });
            marker.on("popupclose", () => {
              if (isRefreshing) {
                return;
              }
              if (activePopupId === id) {
                activePopupId = null;
              }
            });
            markers[id] = marker;
            marker.addTo(layer);
          } else {
            marker.setLatLng([lat, lng]);
            marker.setIcon(markerIcon(iconPath, size));
            marker.options.iconPath = iconPath;
            marker.setPopupContent(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
          }
          seen.add(id);
          if (!String(label).toLowerCase().includes("skoda")) {
            bounds.push([lat, lng]);
          }
        });
        Object.keys(markers).forEach((key) => {
          if (!seen.has(key)) {
            const marker = markers[key];
            layer.removeLayer(marker);
            delete markers[key];
            if (activePopupId === key) {
              activePopupId = null;
            }
          }
        });

        const statusEl = document.getElementById("mapStatus");
        const debugEl = document.getElementById("mapDebug");
        if (statusEl) {
          statusEl.textContent = `Trackers: ${rows.length} | Markers: ${bounds.length}`;
        }
        if (debugEl) {
          const first = rows.find((row) => Number.isFinite(Number(row.lat)) && Number.isFinite(Number(row.lng)));
          const zoom = map.getZoom();
          debugEl.textContent = first
            ? `| zoom ${zoom} | ${Number(first.lat).toFixed(5)}, ${Number(first.lng).toFixed(5)}`
            : `| zoom ${zoom} | no lat/lng`;
        }

        if (!fitted) {
          if (bounds.length === 1) {
            map.setView(bounds[0], 15);
          } else {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          fitted = true;
        }
        if (activePopupId && markers[activePopupId]) {
          markers[activePopupId].openPopup();
        }
        isRefreshing = false;
      }

      async function loadData() {
        try {
          const response = await fetch(LIVE_API_URL);
          if (!response.ok) {
            throw new Error("fetch failed");
          }
          const payload = await response.json();
          lastRows = payload.rows || [];
          updateMarkers(lastRows);
          renderTable(lastRows);
        } catch (error) {
          const statusEl = document.getElementById("mapStatus");
          if (statusEl) {
            statusEl.textContent = "Failed to load live data.";
          }
        }
      }

      loadData();
      setInterval(loadData, POLL_INTERVAL_MS);

      fetch("llbg_layers.geojson")
        .then((res) => res.json())
        .then((data) => {
          L.geoJSON(data, {
            pointToLayer: (feature, latlng) =>
              L.circleMarker(latlng, {
                radius: 7,
                color: "#7c3aed",
                fillColor: "#a855f7",
                fillOpacity: 0.9,
                weight: 2,
              }),
            onEachFeature: (feature, layer) => {
              const name = feature.properties?.name || "LLBG point";
              const source = feature.properties?.source || "";
              layer.bindTooltip(`${name}`, {
                direction: "top",
                permanent: true,
                opacity: 0.9,
                className: "llbg-label",
              });
              layer.bindPopup(`${name}<br/>${source}`);
            },
          }).addTo(llbgLayer);
        })
        .catch(() => {});

      // Removed LLBG chart overlays from the layer list.
    </script>
  </body>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Navixy Live Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .view-tabs {
        position: absolute;
        top: 72px;
        right: 12px;
        z-index: 1000;
        display: flex;
        gap: 6px;
      }

      .view-tab {
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 12px;
      }

      .view-tab.active {
        background: #2563eb;
        border-color: #1d4ed8;
      }

      .view-panel {
        display: none;
        height: 100%;
        width: 100%;
        position: relative;
      }

      .view-panel.active {
        display: block;
      }

      .table-view {
        height: 100%;
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        box-sizing: border-box;
      }

      .table-container {
        max-height: calc(100% - 16px);
        overflow: auto;
        border: 1px solid #1f2937;
        border-radius: 8px;
      }

      table.gse-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      table.gse-table th,
      table.gse-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #1f2937;
        text-align: left;
        vertical-align: top;
      }

      table.gse-table th {
        position: sticky;
        top: 0;
        background: #111827;
        z-index: 1;
      }

      .map-overlay {
        position: absolute;
        top: 12px;
        left: 56px;
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 12px;
        z-index: 1000;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #clearPopup {
        background: #1f2937;
        border: 1px solid #374151;
        color: #ffffff;
        padding: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }

      .map-overlay.debug {
        top: 48px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .map-overlay.legend {
        top: auto;
        bottom: 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .legend-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.4);
      }

      .hidden {
        display: none;
      }

      .llbg-label {
        background: rgba(255, 255, 255, 0.9);
        color: #4c1d95;
        border: 1px solid #c4b5fd;
        border-radius: 4px;
        padding: 1px 4px;
        font-size: 10px;
      }

      .leaflet-tooltip.gse-label {
        border-radius: 6px;
        color: #ffffff !important;
        font-weight: 700;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(0, 0, 0, 0.25) !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
      }
      .leaflet-tooltip.gse-status-available,
      .legend-swatch.gse-status-available { background: #00a651 !important; }
      .leaflet-tooltip.gse-status-in-use,
      .legend-swatch.gse-status-in-use { background: #f97316 !important; }
      .leaflet-tooltip.gse-status-moving,
      .legend-swatch.gse-status-moving { background: #1e88e5 !important; }
      .leaflet-tooltip.gse-status-idle,
      .legend-swatch.gse-status-idle { background: #e91e63 !important; }
      .leaflet-tooltip.gse-status-ignition,
      .legend-swatch.gse-status-ignition { background: #fdd835 !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-working,
      .legend-swatch.gse-status-working { background: #e53935 !important; }
      .leaflet-tooltip.gse-status-maintenance,
      .legend-swatch.gse-status-maintenance { background: #fb8c00 !important; }
      .leaflet-tooltip.gse-status-low-battery,
      .legend-swatch.gse-status-low-battery { background: #fbc02d !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-alert,
      .legend-swatch.gse-status-alert { background: #ef6c00 !important; }
    </style>
  </head>
  <body>
    <div class="view-tabs">
      <button class="view-tab active" data-view="map">Map</button>
      <button class="view-tab" data-view="table">Table</button>
    </div>
    <div id="mapView" class="view-panel active">
      <div id="map"></div>
      <div class="map-overlay">
        <span id="mapStatus">Loading...</span>
        <button id="clearPopup" type="button">Clear</button>
      </div>
      <div id="debugOverlay" class="map-overlay debug hidden">
        <span id="mapDebug">debug</span>
      </div>
      <div id="legendOverlay" class="map-overlay legend hidden">
        <div class="legend-row"><span class="legend-swatch gse-status-available"></span>Available</div>
        <div class="legend-row"><span class="legend-swatch gse-status-in-use"></span>In use</div>
        <div class="legend-row"><span class="legend-swatch gse-status-moving"></span>Moving</div>
        <div class="legend-row"><span class="legend-swatch gse-status-idle"></span>Idle</div>
        <div class="legend-row"><span class="legend-swatch gse-status-ignition"></span>Ignition on</div>
        <div class="legend-row"><span class="legend-swatch gse-status-working"></span>Working</div>
        <div class="legend-row"><span class="legend-swatch gse-status-maintenance"></span>Maintenance</div>
        <div class="legend-row"><span class="legend-swatch gse-status-low-battery"></span>Low battery</div>
        <div class="legend-row"><span class="legend-swatch gse-status-alert"></span>Alert</div>
      </div>
    </div>
    <div id="tableView" class="view-panel table-view">
      <div class="table-container">
        <table class="gse-table">
          <thead id="gseTableHead"></thead>
          <tbody id="gseTableBody"></tbody>
        </table>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const LIVE_API_URL = "https://outside-notebook-sheer-discounted.trycloudflare.com/data";
      const POLL_INTERVAL_MS = 2000;
      const map = L.map("map").setView([32.004, 34.876], 13);
      const layer = L.layerGroup().addTo(map);
      const llbgLayer = L.layerGroup();
      const debugLayer = L.layerGroup();
      const legendLayer = L.layerGroup();
      const chartLayers = {};

      const osmStreets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      const osmStandard = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      });
      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri",
        }
      );
      const baseLayers = {
        "OSM streets": osmStreets,
        OSM: osmStandard,
        "Satellite (Esri)": esriSat,
      };
      const overlayLayers = {
        "LLBG Gates/Zones": llbgLayer,
      };
      const layersControl = L.control
        .layers(
          baseLayers,
          overlayLayers,
          { position: "topright" }
        )
        .addTo(map);
      layersControl.addOverlay(debugLayer, "Debug");
      layersControl.addOverlay(legendLayer, "GSE Legend");

      const markers = {};
      let fitted = false;
      let activePopupId = null;
      let isRefreshing = false;
      let lastRows = [];
      const DASHBOARD_HEADERS = [
        "group_icon",
        "label",
        "imei",
        "group_name",
        "connection_status",
        "movement_status",
        "last_update",
        "nearest_gate",
        "nearest_gate_distance_m",
        "address",
        "best_nearby_zone",
        "best_nearby_distance_m",
        "lat",
        "lng",
        "odometer",
        "engine_hours",
        "Board voltage",
        "Board voltage__updated",
        "Fuel_level",
        "Fuel_level__updated",
        "GSE_Dashboard_warnings",
        "ac_moves_count",
        "brake_pressure_actual",
        "brake_pressure_set",
        "def_level",
        "eng_def_lamp",
        "eng_emc_stop_lamp",
        "eng_hest_lamp",
        "engine_hours_empty",
        "engine_hours_total",
        "engine_hours_with_ac",
        "engine_rpm",
        "engine_rpm__updated",
        "gotis_status",
        "next_service_hours",
        "pickup_state",
        "Gottis",
        "Moving",
        "Moving__updated",
        "Pup_State",
        "Engine_Temp",
        "Engine_Temp__updated",
        "Engine_O.P",
        "Engine_O.P__updated",
        "Fuel",
        "Fuel__updated",
        "BLE: ID",
        "EyeBecon",
        "Hardware key",
        "Hardware key__updated",
        "Ignition",
        "Ignition__updated",
        "Working__updated",
        "OBD: Absolute load value",
        "OBD: Control module voltage",
        "OBD: Coolant temperature",
        "OBD: Fuel",
        "OBD: Fuel consumption",
        "OBD: RPM",
        "OBD: Run time since engine start",
        "OBD: Speed",
        "OBD: Throttle",
        "OBD_ODD",
        "Errors",
        "OBD: Distance with MIL on",
        "OBD: Mileage after DTC reset",
        "VIN",
        "next_service_hours",
        "gse_score",
        "gps_signal",
        "gsm_signal",
        "inputs",
        "outputs",
        "fuel_sensors",
        "sensors_count",
      ];
      const iconCache = new Map();
      const lastPositions = new Map();
      const clearButton = document.getElementById("clearPopup");
      const debugOverlay = document.getElementById("debugOverlay");
      const legendOverlay = document.getElementById("legendOverlay");

      if (clearButton) {
        clearButton.addEventListener("click", () => {
          Object.values(markers).forEach((marker) => marker.closePopup());
          activePopupId = null;
        });
      }

      const viewTabs = document.querySelectorAll(".view-tab");
      const mapView = document.getElementById("mapView");
      const tableView = document.getElementById("tableView");
      viewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          viewTabs.forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          const view = tab.dataset.view;
          if (view === "table") {
            mapView.classList.remove("active");
            tableView.classList.add("active");
          } else {
            tableView.classList.remove("active");
            mapView.classList.add("active");
            map.invalidateSize();
          }
        });
      });

      map.on("overlayadd", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.remove("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.remove("hidden");
        }
      });
      map.on("overlayremove", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.add("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.add("hidden");
        }
      });

      function iconPathForRow(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        const name = `${label} ${group}`;
        if (label.includes("5032")) {
          return "Pictures/towing_barless_transparent.png";
        }
        if (label.includes("6074")) {
          return "Pictures/Champ70_transparent.png";
        }
        if (name.includes("towing") || name.includes("tow") || name.includes("??????")) {
          return "Pictures/TowBar.png";
        }
        if (name.includes("loader") || name.includes("??????")) {
          return "Pictures/Loader.png";
        }
        if (name.includes("acu") || name.includes("a/c")) {
          return "Pictures/TLD ACU.png";
        }
        if (name.includes("gpu")) {
          return "Pictures/TLD GPU.png";
        }
        if (name.includes("stair") || name.includes("stairs")) {
          return "Pictures/staires.png";
        }
        if (name.includes("manito")) {
          return "Pictures/Manito.png";
        }
        if (name.includes("tractor") || name.includes("tracktor") || name.includes("trac")) {
          return "Pictures/Tracktor.png";
        }
        return "Pictures/Aviation1.jpg";
      }

      function markerSizeForZoom(zoom) {
        const safeZoom = Number.isFinite(zoom) ? zoom : 13;
        const size = 14 + (safeZoom - 10) * 3;
        return Math.max(20, Math.min(56, Math.round(size)));
      }

      function markerIcon(path, size) {
        const key = `${path}|${size}`;
        if (!iconCache.has(key)) {
          iconCache.set(
            key,
            L.icon({
              iconUrl: encodeURI(path),
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2],
              popupAnchor: [0, -size / 2],
            })
          );
        }
        return iconCache.get(key);
      }

      function updateMarkerIcons() {
        const size = markerSizeForZoom(map.getZoom());
        Object.values(markers).forEach((marker) => {
          const iconPath = marker.options.iconPath || "Pictures/Aviation1.jpg";
          marker.setIcon(markerIcon(iconPath, size));
        });
      }

      map.on("zoomend", updateMarkerIcons);

      const LOW_FUEL_THRESHOLD = 20;
      const LOW_BATTERY_THRESHOLD = 24;
      const MOVE_DISTANCE_METERS = 10;

      function parseNumber(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const num = Number(String(value).replace(/[^\d.-]/g, ""));
        return Number.isFinite(num) ? num : null;
      }

      function parseBoolean(value) {
        if (value === null || value === undefined) {
          return false;
        }
        if (typeof value === "boolean") {
          return value;
        }
        const text = String(value).trim().toLowerCase();
        return text === "on" || text === "true" || text === "1" || text === "yes" || text === "active";
      }

      function distanceMeters(lat1, lon1, lat2, lon2) {
        const toRad = (deg) => (deg * Math.PI) / 180;
        const r = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lat2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return r * c;
      }

      function updateDistance(id, lat, lng) {
        const prev = lastPositions.get(id);
        lastPositions.set(id, { lat, lng });
        if (!prev) {
          return 0;
        }
        return distanceMeters(prev.lat, prev.lng, lat, lng);
      }

      function isMoving(row) {
        const status = String(row.movement_status || "").toLowerCase();
        if (status.includes("moving")) {
          return true;
        }
        const speed = parseNumber(row.speed ?? row.Speed);
        return speed !== null ? speed > 0.5 : false;
      }

      function isIgnitionOn(row) {
        const ignition =
          row.Ignition ??
          row.ignition ??
          row["Ignition"] ??
          row["Ignition status"] ??
          row["ignition_status"] ??
          row.input1 ??
          row["input1"] ??
          row["Input1"] ??
          row["Input 1"];
        if (parseBoolean(ignition)) {
          return true;
        }
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        return rpm !== null ? rpm > 0 : false;
      }

      function isLoader(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        return label.includes("loader") || group.includes("loader") || label.includes("6074");
      }

      function isWorking(row, moving) {
        if (moving) {
          return false;
        }
        if (isIgnitionOn(row)) {
          return true;
        }
        const workingFlag =
          parseBoolean(row.Working) ||
          parseBoolean(row.working) ||
          parseBoolean(row["Working-Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer_Extract"]);
        const oilPressure = parseNumber(row["Engine_O.P"] ?? row.Engine_O_P ?? row.Engine_OP);
        if (workingFlag) {
          return true;
        }
        if (isLoader(row) && oilPressure !== null) {
          return oilPressure > 2;
        }
        return false;
      }

      function isAlert(row) {
        const fuel = parseNumber(row.Fuel_level ?? row.Fuel ?? row["Fuel level"]);
        const battery = parseNumber(
          row["Battery level"] ??
            row.battery_level ??
            row.Voltage ??
            row.voltage ??
            row["Board voltage"]
        );
        const lowFuel = fuel !== null ? fuel < LOW_FUEL_THRESHOLD : false;
        const lowBattery = battery !== null ? battery < LOW_BATTERY_THRESHOLD : false;
        const nextService = parseNumber(row.next_service_hours ?? row["Next Service"]);
        const alertFlag =
          parseBoolean(row.Alert) ||
          parseBoolean(row.alert) ||
          parseBoolean(row["Repair requested"]);
        const nextServiceDue = nextService !== null ? nextService <= 0 : false;
        return lowFuel || nextServiceDue || alertFlag || lowBattery;
      }

      function statusLabel(row) {
        return row.movement_status || row.connection_status || "unknown";
      }

      function statusClass(row, moving, distanceMetersValue) {
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        const maintenance =
          parseBoolean(row["Maintenance zone"]) ||
          parseBoolean(row.maintenance_zone) ||
          parseBoolean(row["In maintenance"]);
        const navixyStatus = String(row.movement_status || row.connection_status || "")
          .toLowerCase()
          .trim();

        if (isAlert(row)) {
          return "gse-status-alert";
        }
        if (maintenance) {
          return "gse-status-maintenance";
        }
        if (parseNumber(row.Voltage ?? row.voltage) !== null) {
          const voltage = parseNumber(row.Voltage ?? row.voltage);
          if (voltage !== null && voltage < LOW_BATTERY_THRESHOLD) {
            return "gse-status-low-battery";
          }
        }
        if (isWorking(row, moving)) {
          return "gse-status-working";
        }
        if (navixyStatus.includes("moving")) {
          return "gse-status-moving";
        }
        if (navixyStatus.includes("idle")) {
          return "gse-status-idle";
        }
        if (
          navixyStatus.includes("standstill") ||
          navixyStatus.includes("park") ||
          navixyStatus.includes("stopp")
        ) {
          return "gse-status-available";
        }
        if (navixyStatus.includes("offline")) {
          return "gse-status-stop";
        }
        if (moving || distanceMetersValue > MOVE_DISTANCE_METERS) {
          return "gse-status-moving";
        }
        if (rpm !== null && rpm !== 0) {
          return "gse-status-in-use";
        }
        if (rpm !== null && rpm < 2000 && distanceMetersValue <= MOVE_DISTANCE_METERS) {
          return "gse-status-idle";
        }
        if (isIgnitionOn(row)) {
          return "gse-status-ignition";
        }
        return "gse-status-available";
      }

      function updateTooltip(marker, text, className) {
        if (!marker.getTooltip()) {
          marker.bindTooltip(text, {
            permanent: true,
            direction: "top",
            offset: [0, -12],
            className: `gse-label ${className}`,
          });
          return;
        }
        marker.setTooltipContent(text);
        marker.getTooltip().options.className = `gse-label ${className}`;
        if (marker.getTooltip()._container) {
          marker.getTooltip()._container.className = `leaflet-tooltip gse-label ${className}`;
        }
      }

      function formatLabel(row) {
        const label = row.label || row.tracker_id || "";
        const match = String(label).match(/(\d{4})/);
        return match ? match[1] : String(label);
      }

      function formatStatus(row) {
        return row.movement_status || row.connection_status || "--";
      }

      function formatSensor(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("Fuel", row.Fuel_level ?? row.Fuel);
        add("Voltage", row["Board voltage"] ?? row.Voltage ?? row.voltage);
        add("EngTemp", row.Engine_Temp ?? row.engine_temperature);
        add("EngOP", row["Engine_O.P"]);
        add("RPM", row.engine_rpm);
        return parts.length ? parts.join(" | ") : "--";
      }

      function formatBeacon(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("BLE", row["BLE: ID"]);
        add("EyeBecon", row.EyeBecon);
        add("Key", row["Hardware key"]);
        return parts.length ? parts.join(" | ") : "--";
      }

      function renderTable(rows) {
        const head = document.getElementById("gseTableHead");
        const body = document.getElementById("gseTableBody");
        if (!head || !body) {
          return;
        }
        const headers = DASHBOARD_HEADERS.flatMap((h) => (h === "label" ? ["label", "label_updated"] : [h]));
        head.innerHTML = `<tr>${headers.map((h) => `<th>${h}</th>`).join("")}</tr>`;
        body.innerHTML = rows
          .map((row) => {
            const cells = headers.map((h) => {
              if (h === "label") {
                return formatLabel(row);
              }
              if (h === "label_updated") {
                return row.last_update || row.gps_updated || "--";
              }
              if (h.endsWith("__updated")) {
                return row[h] ?? "--";
              }
              return row[h] ?? "--";
            })
              .map((value) => `<td>${value}</td>`)
              .join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");
      }

      function popupHtml(row) {
        const label = row.label || row.tracker_id || "tracker";
        const lat = row.lat;
        const lng = row.lng;
        const status = statusLabel(row);
        const base = `<strong>${label}</strong><br/>${status}<br/>${lat}, ${lng}`;
        const extra = [];
        const sensorUpdated = (() => {
          const candidates = Object.keys(row || {})
            .filter((key) => key.endsWith("__updated"))
            .map((key) => row[key])
            .filter(Boolean);
          let latestRaw = null;
          let latestTime = null;
          candidates.forEach((value) => {
            const parsed = Date.parse(value);
            if (Number.isNaN(parsed)) {
              if (!latestRaw) {
                latestRaw = value;
              }
              return;
            }
            if (latestTime === null || parsed > latestTime) {
              latestTime = parsed;
              latestRaw = value;
            }
          });
          return latestRaw;
        })();
        const ignition = isIgnitionOn(row) ? "on" : "off";
        const ignitionUpdated = row["Ignition__updated"] ?? row["ignition__updated"];
        extra.push(`Ignition: ${ignition}${ignitionUpdated ? ` (updated ${ignitionUpdated})` : ""}`);
        const statusUpdated = row.last_update || row.gps_updated;
        if (statusUpdated) {
          extra.push(`Last status report: ${statusUpdated}`);
        }
        if (sensorUpdated) {
          extra.push(`Last sensor report: ${sensorUpdated}`);
        }
        if (label.includes("6074")) {
          const tempUpdated = row["Engine_Temp__updated"];
          const opUpdated = row["Engine_O.P__updated"];
          const fuelUpdated = row["Fuel__updated"];
          extra.push(
            `Engine_Temp: ${row.Engine_Temp ?? "--"}${tempUpdated ? ` (updated ${tempUpdated})` : ""}`
          );
          extra.push(
            `Engine_O.P: ${row["Engine_O.P"] ?? "--"}${opUpdated ? ` (updated ${opUpdated})` : ""}`
          );
          extra.push(`Fuel: ${row.Fuel ?? "--"}${fuelUpdated ? ` (updated ${fuelUpdated})` : ""}`);
          extra.push(`Engine Hours: ${row.engine_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        if (label.includes("5032")) {
          const fuelLevelUpdated = row["Fuel_level__updated"];
          const rpmUpdated = row["engine_rpm__updated"];
          extra.push(
            `Fuel_level: ${row.Fuel_level ?? "--"}${fuelLevelUpdated ? ` (updated ${fuelLevelUpdated})` : ""}`
          );
          extra.push(
            `Engine RPM: ${row.engine_rpm ?? "--"}${rpmUpdated ? ` (updated ${rpmUpdated})` : ""}`
          );
          extra.push(`Engine Hours: ${row.engine_hours_total ?? row.engine_hours ?? "--"}`);
          extra.push(`Next Service: ${row.next_service_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        return `${base}${extra.length ? "<br/>" + extra.join("<br/>") : ""}`;
      }

      function updateMarkers(rows) {
        isRefreshing = true;
        if (!map.hasLayer(layer)) {
          layer.addTo(map);
        }
        const bounds = [];
        const seen = new Set();
        rows.forEach((row) => {
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            return;
          }
          const label = row.label || row.tracker_id || "tracker";
          const shortMatch = String(label).match(/(\d{4})/);
          const shortLabel = shortMatch ? shortMatch[1] : label;
          const id = String(row.tracker_id || label);
          const iconPath = iconPathForRow(row);
          const size = markerSizeForZoom(map.getZoom());
          const distanceMetersValue = updateDistance(id, lat, lng);
          const moving = isMoving(row) || distanceMetersValue > MOVE_DISTANCE_METERS;
          const labelClass = statusClass(row, moving, distanceMetersValue);
          let marker = markers[id];
          if (!marker) {
            marker = L.marker([lat, lng], {
              icon: markerIcon(iconPath, size),
              iconPath,
            })
              .bindPopup(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
            marker.off("click", marker._openPopup);
            marker.on("click", () => {
              marker.openPopup();
              activePopupId = id;
            });
            marker.on("popupclose", () => {
              if (isRefreshing) {
                return;
              }
              if (activePopupId === id) {
                activePopupId = null;
              }
            });
            markers[id] = marker;
            marker.addTo(layer);
          } else {
            marker.setLatLng([lat, lng]);
            marker.setIcon(markerIcon(iconPath, size));
            marker.options.iconPath = iconPath;
            marker.setPopupContent(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
          }
          seen.add(id);
          if (!String(label).toLowerCase().includes("skoda")) {
            bounds.push([lat, lng]);
          }
        });
        Object.keys(markers).forEach((key) => {
          if (!seen.has(key)) {
            const marker = markers[key];
            layer.removeLayer(marker);
            delete markers[key];
            if (activePopupId === key) {
              activePopupId = null;
            }
          }
        });

        const statusEl = document.getElementById("mapStatus");
        const debugEl = document.getElementById("mapDebug");
        if (statusEl) {
          statusEl.textContent = `Trackers: ${rows.length} | Markers: ${bounds.length}`;
        }
        if (debugEl) {
          const first = rows.find((row) => Number.isFinite(Number(row.lat)) && Number.isFinite(Number(row.lng)));
          const zoom = map.getZoom();
          debugEl.textContent = first
            ? `| zoom ${zoom} | ${Number(first.lat).toFixed(5)}, ${Number(first.lng).toFixed(5)}`
            : `| zoom ${zoom} | no lat/lng`;
        }

        if (!fitted) {
          if (bounds.length === 1) {
            map.setView(bounds[0], 15);
          } else {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          fitted = true;
        }
        if (activePopupId && markers[activePopupId]) {
          markers[activePopupId].openPopup();
        }
        isRefreshing = false;
      }

      async function loadData() {
        try {
          const response = await fetch(LIVE_API_URL);
          if (!response.ok) {
            throw new Error("fetch failed");
          }
          const payload = await response.json();
          lastRows = payload.rows || [];
          updateMarkers(lastRows);
          renderTable(lastRows);
        } catch (error) {
          const statusEl = document.getElementById("mapStatus");
          if (statusEl) {
            statusEl.textContent = "Failed to load live data.";
          }
        }
      }

      loadData();
      setInterval(loadData, POLL_INTERVAL_MS);

      fetch("llbg_layers.geojson")
        .then((res) => res.json())
        .then((data) => {
          L.geoJSON(data, {
            pointToLayer: (feature, latlng) =>
              L.circleMarker(latlng, {
                radius: 7,
                color: "#7c3aed",
                fillColor: "#a855f7",
                fillOpacity: 0.9,
                weight: 2,
              }),
            onEachFeature: (feature, layer) => {
              const name = feature.properties?.name || "LLBG point";
              const source = feature.properties?.source || "";
              layer.bindTooltip(`${name}`, {
                direction: "top",
                permanent: true,
                opacity: 0.9,
                className: "llbg-label",
              });
              layer.bindPopup(`${name}<br/>${source}`);
            },
          }).addTo(llbgLayer);
        })
        .catch(() => {});

      // Removed LLBG chart overlays from the layer list.
    </script>
  </body>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Navixy Live Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .view-tabs {
        position: absolute;
        top: 72px;
        right: 12px;
        z-index: 1000;
        display: flex;
        gap: 6px;
      }

      .view-tab {
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 12px;
      }

      .view-tab.active {
        background: #2563eb;
        border-color: #1d4ed8;
      }

      .view-panel {
        display: none;
        height: 100%;
        width: 100%;
        position: relative;
      }

      .view-panel.active {
        display: block;
      }

      .table-view {
        height: 100%;
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        box-sizing: border-box;
      }

      .table-container {
        max-height: calc(100% - 16px);
        overflow: auto;
        border: 1px solid #1f2937;
        border-radius: 8px;
      }

      table.gse-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      table.gse-table th,
      table.gse-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #1f2937;
        text-align: left;
        vertical-align: top;
      }

      table.gse-table th {
        position: sticky;
        top: 0;
        background: #111827;
        z-index: 1;
      }

      .map-overlay {
        position: absolute;
        top: 12px;
        left: 56px;
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 12px;
        z-index: 1000;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #clearPopup {
        background: #1f2937;
        border: 1px solid #374151;
        color: #ffffff;
        padding: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }

      .map-overlay.debug {
        top: 48px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .map-overlay.legend {
        top: auto;
        bottom: 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .legend-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.4);
      }

      .hidden {
        display: none;
      }

      .llbg-label {
        background: rgba(255, 255, 255, 0.9);
        color: #4c1d95;
        border: 1px solid #c4b5fd;
        border-radius: 4px;
        padding: 1px 4px;
        font-size: 10px;
      }

      .leaflet-tooltip.gse-label {
        border-radius: 6px;
        color: #ffffff !important;
        font-weight: 700;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(0, 0, 0, 0.25) !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
      }
      .leaflet-tooltip.gse-status-available,
      .legend-swatch.gse-status-available { background: #00a651 !important; }
      .leaflet-tooltip.gse-status-in-use,
      .legend-swatch.gse-status-in-use { background: #f97316 !important; }
      .leaflet-tooltip.gse-status-moving,
      .legend-swatch.gse-status-moving { background: #1e88e5 !important; }
      .leaflet-tooltip.gse-status-idle,
      .legend-swatch.gse-status-idle { background: #e91e63 !important; }
      .leaflet-tooltip.gse-status-ignition,
      .legend-swatch.gse-status-ignition { background: #fdd835 !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-working,
      .legend-swatch.gse-status-working { background: #e53935 !important; }
      .leaflet-tooltip.gse-status-maintenance,
      .legend-swatch.gse-status-maintenance { background: #fb8c00 !important; }
      .leaflet-tooltip.gse-status-low-battery,
      .legend-swatch.gse-status-low-battery { background: #fbc02d !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-alert,
      .legend-swatch.gse-status-alert { background: #ef6c00 !important; }
    </style>
  </head>
  <body>
    <div class="view-tabs">
      <button class="view-tab active" data-view="map">Map</button>
      <button class="view-tab" data-view="table">Table</button>
    </div>
    <div id="mapView" class="view-panel active">
      <div id="map"></div>
      <div class="map-overlay">
        <span id="mapStatus">Loading...</span>
        <button id="clearPopup" type="button">Clear</button>
      </div>
      <div id="debugOverlay" class="map-overlay debug hidden">
        <span id="mapDebug">debug</span>
      </div>
      <div id="legendOverlay" class="map-overlay legend hidden">
        <div class="legend-row"><span class="legend-swatch gse-status-available"></span>Available</div>
        <div class="legend-row"><span class="legend-swatch gse-status-in-use"></span>In use</div>
        <div class="legend-row"><span class="legend-swatch gse-status-moving"></span>Moving</div>
        <div class="legend-row"><span class="legend-swatch gse-status-idle"></span>Idle</div>
        <div class="legend-row"><span class="legend-swatch gse-status-ignition"></span>Ignition on</div>
        <div class="legend-row"><span class="legend-swatch gse-status-working"></span>Working</div>
        <div class="legend-row"><span class="legend-swatch gse-status-maintenance"></span>Maintenance</div>
        <div class="legend-row"><span class="legend-swatch gse-status-low-battery"></span>Low battery</div>
        <div class="legend-row"><span class="legend-swatch gse-status-alert"></span>Alert</div>
      </div>
    </div>
    <div id="tableView" class="view-panel table-view">
      <div class="table-container">
        <table class="gse-table">
          <thead id="gseTableHead"></thead>
          <tbody id="gseTableBody"></tbody>
        </table>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const LIVE_API_URL = "https://outside-notebook-sheer-discounted.trycloudflare.com/data";
      const POLL_INTERVAL_MS = 2000;
      const map = L.map("map").setView([32.004, 34.876], 13);
      const layer = L.layerGroup().addTo(map);
      const llbgLayer = L.layerGroup();
      const debugLayer = L.layerGroup();
      const legendLayer = L.layerGroup();
      const chartLayers = {};

      const osmStreets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      const osmStandard = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      });
      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri",
        }
      );
      const baseLayers = {
        "OSM streets": osmStreets,
        OSM: osmStandard,
        "Satellite (Esri)": esriSat,
      };
      const overlayLayers = {
        "LLBG Gates/Zones": llbgLayer,
      };
      const layersControl = L.control
        .layers(
          baseLayers,
          overlayLayers,
          { position: "topright" }
        )
        .addTo(map);
      layersControl.addOverlay(debugLayer, "Debug");
      layersControl.addOverlay(legendLayer, "GSE Legend");

      const markers = {};
      let fitted = false;
      let activePopupId = null;
      let isRefreshing = false;
      let lastRows = [];
      const DASHBOARD_HEADERS = [
        "group_icon",
        "label",
        "imei",
        "group_name",
        "connection_status",
        "movement_status",
        "last_update",
        "nearest_gate",
        "nearest_gate_distance_m",
        "address",
        "best_nearby_zone",
        "best_nearby_distance_m",
        "lat",
        "lng",
        "odometer",
        "engine_hours",
        "Board voltage",
        "Board voltage__updated",
        "Fuel_level",
        "Fuel_level__updated",
        "GSE_Dashboard_warnings",
        "ac_moves_count",
        "brake_pressure_actual",
        "brake_pressure_set",
        "def_level",
        "eng_def_lamp",
        "eng_emc_stop_lamp",
        "eng_hest_lamp",
        "engine_hours_empty",
        "engine_hours_total",
        "engine_hours_with_ac",
        "engine_rpm",
        "engine_rpm__updated",
        "gotis_status",
        "next_service_hours",
        "pickup_state",
        "Gottis",
        "Moving",
        "Moving__updated",
        "Pup_State",
        "Engine_Temp",
        "Engine_Temp__updated",
        "Engine_O.P",
        "Engine_O.P__updated",
        "Fuel",
        "Fuel__updated",
        "BLE: ID",
        "EyeBecon",
        "Hardware key",
        "Hardware key__updated",
        "Ignition",
        "Ignition__updated",
        "Working__updated",
        "OBD: Absolute load value",
        "OBD: Control module voltage",
        "OBD: Coolant temperature",
        "OBD: Fuel",
        "OBD: Fuel consumption",
        "OBD: RPM",
        "OBD: Run time since engine start",
        "OBD: Speed",
        "OBD: Throttle",
        "OBD_ODD",
        "Errors",
        "OBD: Distance with MIL on",
        "OBD: Mileage after DTC reset",
        "VIN",
        "next_service_hours",
        "gse_score",
        "gps_signal",
        "gsm_signal",
        "inputs",
        "outputs",
        "fuel_sensors",
        "sensors_count",
      ];
      const iconCache = new Map();
      const lastPositions = new Map();
      const clearButton = document.getElementById("clearPopup");
      const debugOverlay = document.getElementById("debugOverlay");
      const legendOverlay = document.getElementById("legendOverlay");

      if (clearButton) {
        clearButton.addEventListener("click", () => {
          Object.values(markers).forEach((marker) => marker.closePopup());
          activePopupId = null;
        });
      }

      const viewTabs = document.querySelectorAll(".view-tab");
      const mapView = document.getElementById("mapView");
      const tableView = document.getElementById("tableView");
      viewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          viewTabs.forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          const view = tab.dataset.view;
          if (view === "table") {
            mapView.classList.remove("active");
            tableView.classList.add("active");
          } else {
            tableView.classList.remove("active");
            mapView.classList.add("active");
            map.invalidateSize();
          }
        });
      });

      map.on("overlayadd", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.remove("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.remove("hidden");
        }
      });
      map.on("overlayremove", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.add("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.add("hidden");
        }
      });

      function iconPathForRow(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        const name = `${label} ${group}`;
        if (label.includes("5032")) {
          return "Pictures/towing_barless_transparent.png";
        }
        if (label.includes("6074")) {
          return "Pictures/Champ70_transparent.png";
        }
        if (name.includes("towing") || name.includes("tow") || name.includes("??????")) {
          return "Pictures/TowBar.png";
        }
        if (name.includes("loader") || name.includes("??????")) {
          return "Pictures/Loader.png";
        }
        if (name.includes("acu") || name.includes("a/c")) {
          return "Pictures/TLD ACU.png";
        }
        if (name.includes("gpu")) {
          return "Pictures/TLD GPU.png";
        }
        if (name.includes("stair") || name.includes("stairs")) {
          return "Pictures/staires.png";
        }
        if (name.includes("manito")) {
          return "Pictures/Manito.png";
        }
        if (name.includes("tractor") || name.includes("tracktor") || name.includes("trac")) {
          return "Pictures/Tracktor.png";
        }
        return "Pictures/Aviation1.jpg";
      }

      function markerSizeForZoom(zoom) {
        const safeZoom = Number.isFinite(zoom) ? zoom : 13;
        const size = 14 + (safeZoom - 10) * 3;
        return Math.max(20, Math.min(56, Math.round(size)));
      }

      function markerIcon(path, size) {
        const key = `${path}|${size}`;
        if (!iconCache.has(key)) {
          iconCache.set(
            key,
            L.icon({
              iconUrl: encodeURI(path),
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2],
              popupAnchor: [0, -size / 2],
            })
          );
        }
        return iconCache.get(key);
      }

      function updateMarkerIcons() {
        const size = markerSizeForZoom(map.getZoom());
        Object.values(markers).forEach((marker) => {
          const iconPath = marker.options.iconPath || "Pictures/Aviation1.jpg";
          marker.setIcon(markerIcon(iconPath, size));
        });
      }

      map.on("zoomend", updateMarkerIcons);

      const LOW_FUEL_THRESHOLD = 20;
      const LOW_BATTERY_THRESHOLD = 24;
      const MOVE_DISTANCE_METERS = 10;

      function parseNumber(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const num = Number(String(value).replace(/[^\d.-]/g, ""));
        return Number.isFinite(num) ? num : null;
      }

      function parseBoolean(value) {
        if (value === null || value === undefined) {
          return false;
        }
        if (typeof value === "boolean") {
          return value;
        }
        const text = String(value).trim().toLowerCase();
        return text === "on" || text === "true" || text === "1" || text === "yes" || text === "active";
      }

      function distanceMeters(lat1, lon1, lat2, lon2) {
        const toRad = (deg) => (deg * Math.PI) / 180;
        const r = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return r * c;
      }

      function updateDistance(id, lat, lng) {
        const prev = lastPositions.get(id);
        lastPositions.set(id, { lat, lng });
        if (!prev) {
          return 0;
        }
        return distanceMeters(prev.lat, prev.lng, lat, lng);
      }

      function isMoving(row) {
        const status = String(row.movement_status || "").toLowerCase();
        if (status.includes("moving")) {
          return true;
        }
        const speed = parseNumber(row.speed ?? row.Speed);
        return speed !== null ? speed > 0.5 : false;
      }

      function isIgnitionOn(row) {
        const ignition =
          row.Ignition ??
          row.ignition ??
          row["Ignition"] ??
          row["Ignition status"] ??
          row["ignition_status"] ??
          row.input1 ??
          row["input1"] ??
          row["Input1"] ??
          row["Input 1"];
        if (parseBoolean(ignition)) {
          return true;
        }
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        return rpm !== null ? rpm > 0 : false;
      }

      function isLoader(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        return label.includes("loader") || group.includes("loader") || label.includes("6074");
      }

      function isWorking(row, moving) {
        if (moving) {
          return false;
        }
        if (isIgnitionOn(row)) {
          return true;
        }
        const workingFlag =
          parseBoolean(row.Working) ||
          parseBoolean(row.working) ||
          parseBoolean(row["Working-Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer_Extract"]);
        const oilPressure = parseNumber(row["Engine_O.P"] ?? row.Engine_O_P ?? row.Engine_OP);
        if (workingFlag) {
          return true;
        }
        if (isLoader(row) && oilPressure !== null) {
          return oilPressure > 2;
        }
        return false;
      }

      function isAlert(row) {
        const fuel = parseNumber(row.Fuel_level ?? row.Fuel ?? row["Fuel level"]);
        const battery = parseNumber(
          row["Battery level"] ??
            row.battery_level ??
            row.Voltage ??
            row.voltage ??
            row["Board voltage"]
        );
        const lowFuel = fuel !== null ? fuel < LOW_FUEL_THRESHOLD : false;
        const lowBattery = battery !== null ? battery < LOW_BATTERY_THRESHOLD : false;
        const nextService = parseNumber(row.next_service_hours ?? row["Next Service"]);
        const alertFlag =
          parseBoolean(row.Alert) ||
          parseBoolean(row.alert) ||
          parseBoolean(row["Repair requested"]);
        const nextServiceDue = nextService !== null ? nextService <= 0 : false;
        return lowFuel || nextServiceDue || alertFlag || lowBattery;
      }

      function statusLabel(row) {
        return row.movement_status || row.connection_status || "unknown";
      }

      function statusClass(row, moving, distanceMetersValue) {
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        const maintenance =
          parseBoolean(row["Maintenance zone"]) ||
          parseBoolean(row.maintenance_zone) ||
          parseBoolean(row["In maintenance"]);
        const navixyStatus = String(row.movement_status || row.connection_status || "")
          .toLowerCase()
          .trim();

        if (isAlert(row)) {
          return "gse-status-alert";
        }
        if (maintenance) {
          return "gse-status-maintenance";
        }
        if (parseNumber(row.Voltage ?? row.voltage) !== null) {
          const voltage = parseNumber(row.Voltage ?? row.voltage);
          if (voltage !== null && voltage < LOW_BATTERY_THRESHOLD) {
            return "gse-status-low-battery";
          }
        }
        if (isWorking(row, moving)) {
          return "gse-status-working";
        }
        if (navixyStatus.includes("moving")) {
          return "gse-status-moving";
        }
        if (navixyStatus.includes("idle")) {
          return "gse-status-idle";
        }
        if (
          navixyStatus.includes("standstill") ||
          navixyStatus.includes("park") ||
          navixyStatus.includes("stopp")
        ) {
          return "gse-status-available";
        }
        if (navixyStatus.includes("offline")) {
          return "gse-status-stop";
        }
        if (moving || distanceMetersValue > MOVE_DISTANCE_METERS) {
          return "gse-status-moving";
        }
        if (rpm !== null && rpm !== 0) {
          return "gse-status-in-use";
        }
        if (rpm !== null && rpm < 2000 && distanceMetersValue <= MOVE_DISTANCE_METERS) {
          return "gse-status-idle";
        }
        if (isIgnitionOn(row)) {
          return "gse-status-ignition";
        }
        return "gse-status-available";
      }

      function updateTooltip(marker, text, className) {
        if (!marker.getTooltip()) {
          marker.bindTooltip(text, {
            permanent: true,
            direction: "top",
            offset: [0, -12],
            className: `gse-label ${className}`,
          });
          return;
        }
        marker.setTooltipContent(text);
        marker.getTooltip().options.className = `gse-label ${className}`;
        if (marker.getTooltip()._container) {
          marker.getTooltip()._container.className = `leaflet-tooltip gse-label ${className}`;
        }
      }

      function formatLabel(row) {
        const label = row.label || row.tracker_id || "";
        const match = String(label).match(/(\d{4})/);
        return match ? match[1] : String(label);
      }

      function formatStatus(row) {
        return row.movement_status || row.connection_status || "--";
      }

      function formatSensor(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("Fuel", row.Fuel_level ?? row.Fuel);
        add("Voltage", row["Board voltage"] ?? row.Voltage ?? row.voltage);
        add("EngTemp", row.Engine_Temp ?? row.engine_temperature);
        add("EngOP", row["Engine_O.P"]);
        add("RPM", row.engine_rpm);
        return parts.length ? parts.join(" | ") : "--";
      }

      function formatBeacon(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("BLE", row["BLE: ID"]);
        add("EyeBecon", row.EyeBecon);
        add("Key", row["Hardware key"]);
        return parts.length ? parts.join(" | ") : "--";
      }

      function renderTable(rows) {
        const head = document.getElementById("gseTableHead");
        const body = document.getElementById("gseTableBody");
        if (!head || !body) {
          return;
        }
        const headers = DASHBOARD_HEADERS.flatMap((h) => (h === "label" ? ["label", "label_updated"] : [h]));
        head.innerHTML = `<tr>${headers.map((h) => `<th>${h}</th>`).join("")}</tr>`;
        body.innerHTML = rows
          .map((row) => {
            const cells = headers.map((h) => {
              if (h === "label") {
                return formatLabel(row);
              }
              if (h === "label_updated") {
                return row.last_update || row.gps_updated || "--";
              }
              if (h.endsWith("__updated")) {
                return row[h] ?? "--";
              }
              return row[h] ?? "--";
            })
              .map((value) => `<td>${value}</td>`)
              .join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");
      }

      function popupHtml(row) {
        const label = row.label || row.tracker_id || "tracker";
        const lat = row.lat;
        const lng = row.lng;
        const status = statusLabel(row);
        const base = `<strong>${label}</strong><br/>${status}<br/>${lat}, ${lng}`;
        const extra = [];
        const sensorUpdated = (() => {
          const candidates = Object.keys(row || {})
            .filter((key) => key.endsWith("__updated"))
            .map((key) => row[key])
            .filter(Boolean);
          let latestRaw = null;
          let latestTime = null;
          candidates.forEach((value) => {
            const parsed = Date.parse(value);
            if (Number.isNaN(parsed)) {
              if (!latestRaw) {
                latestRaw = value;
              }
              return;
            }
            if (latestTime === null || parsed > latestTime) {
              latestTime = parsed;
              latestRaw = value;
            }
          });
          return latestRaw;
        })();
        const ignition = isIgnitionOn(row) ? "on" : "off";
        const ignitionUpdated = row["Ignition__updated"] ?? row["ignition__updated"];
        extra.push(`Ignition: ${ignition}${ignitionUpdated ? ` (updated ${ignitionUpdated})` : ""}`);
        const statusUpdated = row.last_update || row.gps_updated;
        if (statusUpdated) {
          extra.push(`Last status report: ${statusUpdated}`);
        }
        if (sensorUpdated) {
          extra.push(`Last sensor report: ${sensorUpdated}`);
        }
        if (label.includes("6074")) {
          const tempUpdated = row["Engine_Temp__updated"];
          const opUpdated = row["Engine_O.P__updated"];
          const fuelUpdated = row["Fuel__updated"];
          extra.push(
            `Engine_Temp: ${row.Engine_Temp ?? "--"}${tempUpdated ? ` (updated ${tempUpdated})` : ""}`
          );
          extra.push(
            `Engine_O.P: ${row["Engine_O.P"] ?? "--"}${opUpdated ? ` (updated ${opUpdated})` : ""}`
          );
          extra.push(`Fuel: ${row.Fuel ?? "--"}${fuelUpdated ? ` (updated ${fuelUpdated})` : ""}`);
          extra.push(`Engine Hours: ${row.engine_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        if (label.includes("5032")) {
          const fuelLevelUpdated = row["Fuel_level__updated"];
          const rpmUpdated = row["engine_rpm__updated"];
          extra.push(
            `Fuel_level: ${row.Fuel_level ?? "--"}${fuelLevelUpdated ? ` (updated ${fuelLevelUpdated})` : ""}`
          );
          extra.push(
            `Engine RPM: ${row.engine_rpm ?? "--"}${rpmUpdated ? ` (updated ${rpmUpdated})` : ""}`
          );
          extra.push(`Engine Hours: ${row.engine_hours_total ?? row.engine_hours ?? "--"}`);
          extra.push(`Next Service: ${row.next_service_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        return `${base}${extra.length ? "<br/>" + extra.join("<br/>") : ""}`;
      }

      function updateMarkers(rows) {
        isRefreshing = true;
        if (!map.hasLayer(layer)) {
          layer.addTo(map);
        }
        const bounds = [];
        const seen = new Set();
        rows.forEach((row) => {
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            return;
          }
          const label = row.label || row.tracker_id || "tracker";
          const shortMatch = String(label).match(/(\d{4})/);
          const shortLabel = shortMatch ? shortMatch[1] : label;
          const id = String(row.tracker_id || label);
          const iconPath = iconPathForRow(row);
          const size = markerSizeForZoom(map.getZoom());
          const distanceMetersValue = updateDistance(id, lat, lng);
          const moving = isMoving(row) || distanceMetersValue > MOVE_DISTANCE_METERS;
          const labelClass = statusClass(row, moving, distanceMetersValue);
          let marker = markers[id];
          if (!marker) {
            marker = L.marker([lat, lng], {
              icon: markerIcon(iconPath, size),
              iconPath,
            })
              .bindPopup(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
            marker.off("click", marker._openPopup);
            marker.on("click", () => {
              marker.openPopup();
              activePopupId = id;
            });
            marker.on("popupclose", () => {
              if (isRefreshing) {
                return;
              }
              if (activePopupId === id) {
                activePopupId = null;
              }
            });
            markers[id] = marker;
            marker.addTo(layer);
          } else {
            marker.setLatLng([lat, lng]);
            marker.setIcon(markerIcon(iconPath, size));
            marker.options.iconPath = iconPath;
            marker.setPopupContent(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
          }
          seen.add(id);
          if (!String(label).toLowerCase().includes("skoda")) {
            bounds.push([lat, lng]);
          }
        });
        Object.keys(markers).forEach((key) => {
          if (!seen.has(key)) {
            const marker = markers[key];
            layer.removeLayer(marker);
            delete markers[key];
            if (activePopupId === key) {
              activePopupId = null;
            }
          }
        });

        const statusEl = document.getElementById("mapStatus");
        const debugEl = document.getElementById("mapDebug");
        if (statusEl) {
          statusEl.textContent = `Trackers: ${rows.length} | Markers: ${bounds.length}`;
        }
        if (debugEl) {
          const first = rows.find((row) => Number.isFinite(Number(row.lat)) && Number.isFinite(Number(row.lng)));
          const zoom = map.getZoom();
          debugEl.textContent = first
            ? `| zoom ${zoom} | ${Number(first.lat).toFixed(5)}, ${Number(first.lng).toFixed(5)}`
            : `| zoom ${zoom} | no lat/lng`;
        }

        if (!fitted) {
          if (bounds.length === 1) {
            map.setView(bounds[0], 15);
          } else {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          fitted = true;
        }
        if (activePopupId && markers[activePopupId]) {
          markers[activePopupId].openPopup();
        }
        isRefreshing = false;
      }

      async function loadData() {
        try {
          const response = await fetch(LIVE_API_URL);
          if (!response.ok) {
            throw new Error("fetch failed");
          }
          const payload = await response.json();
          lastRows = payload.rows || [];
          updateMarkers(lastRows);
          renderTable(lastRows);
        } catch (error) {
          const statusEl = document.getElementById("mapStatus");
          if (statusEl) {
            statusEl.textContent = "Failed to load live data.";
          }
        }
      }

      loadData();
      setInterval(loadData, POLL_INTERVAL_MS);

      fetch("llbg_layers.geojson")
        .then((res) => res.json())
        .then((data) => {
          L.geoJSON(data, {
            pointToLayer: (feature, latlng) =>
              L.circleMarker(latlng, {
                radius: 7,
                color: "#7c3aed",
                fillColor: "#a855f7",
                fillOpacity: 0.9,
                weight: 2,
              }),
            onEachFeature: (feature, layer) => {
              const name = feature.properties?.name || "LLBG point";
              const source = feature.properties?.source || "";
              layer.bindTooltip(`${name}`, {
                direction: "top",
                permanent: true,
                opacity: 0.9,
                className: "llbg-label",
              });
              layer.bindPopup(`${name}<br/>${source}`);
            },
          }).addTo(llbgLayer);
        })
        .catch(() => {});

      // Removed LLBG chart overlays from the layer list.
    </script>
  </body>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Navixy Live Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .view-tabs {
        position: absolute;
        top: 72px;
        right: 12px;
        z-index: 1000;
        display: flex;
        gap: 6px;
      }

      .view-tab {
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 12px;
      }

      .view-tab.active {
        background: #2563eb;
        border-color: #1d4ed8;
      }

      .view-panel {
        display: none;
        height: 100%;
        width: 100%;
        position: relative;
      }

      .view-panel.active {
        display: block;
      }

      .table-view {
        height: 100%;
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        box-sizing: border-box;
      }

      .table-container {
        max-height: calc(100% - 16px);
        overflow: auto;
        border: 1px solid #1f2937;
        border-radius: 8px;
      }

      table.gse-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      table.gse-table th,
      table.gse-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #1f2937;
        text-align: left;
        vertical-align: top;
      }

      table.gse-table th {
        position: sticky;
        top: 0;
        background: #111827;
        z-index: 1;
      }

      .map-overlay {
        position: absolute;
        top: 12px;
        left: 56px;
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 12px;
        z-index: 1000;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #clearPopup {
        background: #1f2937;
        border: 1px solid #374151;
        color: #ffffff;
        padding: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
      }

      .map-overlay.debug {
        top: 48px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .map-overlay.legend {
        top: auto;
        bottom: 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
      }

      .legend-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.4);
      }

      .hidden {
        display: none;
      }

      .llbg-label {
        background: rgba(255, 255, 255, 0.9);
        color: #4c1d95;
        border: 1px solid #c4b5fd;
        border-radius: 4px;
        padding: 1px 4px;
        font-size: 10px;
      }

      .leaflet-tooltip.gse-label {
        border-radius: 6px;
        color: #ffffff !important;
        font-weight: 700;
        font-size: 12px;
        padding: 2px 6px;
        border: 1px solid rgba(0, 0, 0, 0.25) !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
      }
      .leaflet-tooltip.gse-status-available,
      .legend-swatch.gse-status-available { background: #00a651 !important; }
      .leaflet-tooltip.gse-status-in-use,
      .legend-swatch.gse-status-in-use { background: #f97316 !important; }
      .leaflet-tooltip.gse-status-moving,
      .legend-swatch.gse-status-moving { background: #1e88e5 !important; }
      .leaflet-tooltip.gse-status-idle,
      .legend-swatch.gse-status-idle { background: #e91e63 !important; }
      .leaflet-tooltip.gse-status-ignition,
      .legend-swatch.gse-status-ignition { background: #fdd835 !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-working,
      .legend-swatch.gse-status-working { background: #e53935 !important; }
      .leaflet-tooltip.gse-status-maintenance,
      .legend-swatch.gse-status-maintenance { background: #fb8c00 !important; }
      .leaflet-tooltip.gse-status-low-battery,
      .legend-swatch.gse-status-low-battery { background: #fbc02d !important; color: #111827 !important; }
      .leaflet-tooltip.gse-status-alert,
      .legend-swatch.gse-status-alert { background: #ef6c00 !important; }
    </style>
  </head>
  <body>
    <div class="view-tabs">
      <button class="view-tab active" data-view="map">Map</button>
      <button class="view-tab" data-view="table">Table</button>
    </div>
    <div id="mapView" class="view-panel active">
      <div id="map"></div>
      <div class="map-overlay">
        <span id="mapStatus">Loading...</span>
        <button id="clearPopup" type="button">Clear</button>
      </div>
      <div id="debugOverlay" class="map-overlay debug hidden">
        <span id="mapDebug">debug</span>
      </div>
      <div id="legendOverlay" class="map-overlay legend hidden">
        <div class="legend-row"><span class="legend-swatch gse-status-available"></span>Available</div>
        <div class="legend-row"><span class="legend-swatch gse-status-in-use"></span>In use</div>
        <div class="legend-row"><span class="legend-swatch gse-status-moving"></span>Moving</div>
        <div class="legend-row"><span class="legend-swatch gse-status-idle"></span>Idle</div>
        <div class="legend-row"><span class="legend-swatch gse-status-ignition"></span>Ignition on</div>
        <div class="legend-row"><span class="legend-swatch gse-status-working"></span>Working</div>
        <div class="legend-row"><span class="legend-swatch gse-status-maintenance"></span>Maintenance</div>
        <div class="legend-row"><span class="legend-swatch gse-status-low-battery"></span>Low battery</div>
        <div class="legend-row"><span class="legend-swatch gse-status-alert"></span>Alert</div>
      </div>
    </div>
    <div id="tableView" class="view-panel table-view">
      <div class="table-container">
        <table class="gse-table">
          <thead id="gseTableHead"></thead>
          <tbody id="gseTableBody"></tbody>
        </table>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const LIVE_API_URL = "https://outside-notebook-sheer-discounted.trycloudflare.com/data";
      const POLL_INTERVAL_MS = 2000;
      const map = L.map("map").setView([32.004, 34.876], 13);
      const layer = L.layerGroup().addTo(map);
      const llbgLayer = L.layerGroup();
      const debugLayer = L.layerGroup();
      const legendLayer = L.layerGroup();
      const chartLayers = {};

      const osmStreets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      const osmStandard = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      });
      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri",
        }
      );
      const baseLayers = {
        "OSM streets": osmStreets,
        OSM: osmStandard,
        "Satellite (Esri)": esriSat,
      };
      const overlayLayers = {
        "LLBG Gates/Zones": llbgLayer,
      };
      const layersControl = L.control
        .layers(
          baseLayers,
          overlayLayers,
          { position: "topright" }
        )
        .addTo(map);
      layersControl.addOverlay(debugLayer, "Debug");
      layersControl.addOverlay(legendLayer, "GSE Legend");

      const markers = {};
      let fitted = false;
      let activePopupId = null;
      let isRefreshing = false;
      let lastRows = [];
      const DASHBOARD_HEADERS = [
        "group_icon",
        "label",
        "imei",
        "group_name",
        "connection_status",
        "movement_status",
        "last_update",
        "nearest_gate",
        "nearest_gate_distance_m",
        "address",
        "best_nearby_zone",
        "best_nearby_distance_m",
        "lat",
        "lng",
        "odometer",
        "engine_hours",
        "Board voltage",
        "Board voltage__updated",
        "Fuel_level",
        "Fuel_level__updated",
        "GSE_Dashboard_warnings",
        "ac_moves_count",
        "brake_pressure_actual",
        "brake_pressure_set",
        "def_level",
        "eng_def_lamp",
        "eng_emc_stop_lamp",
        "eng_hest_lamp",
        "engine_hours_empty",
        "engine_hours_total",
        "engine_hours_with_ac",
        "engine_rpm",
        "engine_rpm__updated",
        "gotis_status",
        "next_service_hours",
        "pickup_state",
        "Gottis",
        "Moving",
        "Moving__updated",
        "Pup_State",
        "Engine_Temp",
        "Engine_Temp__updated",
        "Engine_O.P",
        "Engine_O.P__updated",
        "Fuel",
        "Fuel__updated",
        "BLE: ID",
        "EyeBecon",
        "Hardware key",
        "Hardware key__updated",
        "Ignition",
        "Ignition__updated",
        "Working__updated",
        "OBD: Absolute load value",
        "OBD: Control module voltage",
        "OBD: Coolant temperature",
        "OBD: Fuel",
        "OBD: Fuel consumption",
        "OBD: RPM",
        "OBD: Run time since engine start",
        "OBD: Speed",
        "OBD: Throttle",
        "OBD_ODD",
        "Errors",
        "OBD: Distance with MIL on",
        "OBD: Mileage after DTC reset",
        "VIN",
        "next_service_hours",
        "gse_score",
        "gps_signal",
        "gsm_signal",
        "inputs",
        "outputs",
        "fuel_sensors",
        "sensors_count",
      ];
      const iconCache = new Map();
      const lastPositions = new Map();
      const clearButton = document.getElementById("clearPopup");
      const debugOverlay = document.getElementById("debugOverlay");
      const legendOverlay = document.getElementById("legendOverlay");

      if (clearButton) {
        clearButton.addEventListener("click", () => {
          Object.values(markers).forEach((marker) => marker.closePopup());
          activePopupId = null;
        });
      }

      const viewTabs = document.querySelectorAll(".view-tab");
      const mapView = document.getElementById("mapView");
      const tableView = document.getElementById("tableView");
      viewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          viewTabs.forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          const view = tab.dataset.view;
          if (view === "table") {
            mapView.classList.remove("active");
            tableView.classList.add("active");
          } else {
            tableView.classList.remove("active");
            mapView.classList.add("active");
            map.invalidateSize();
          }
        });
      });

      map.on("overlayadd", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.remove("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.remove("hidden");
        }
      });
      map.on("overlayremove", (event) => {
        if (event.layer === debugLayer && debugOverlay) {
          debugOverlay.classList.add("hidden");
        }
        if (event.layer === legendLayer && legendOverlay) {
          legendOverlay.classList.add("hidden");
        }
      });

      function iconPathForRow(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        const name = `${label} ${group}`;
        if (label.includes("5032")) {
          return "Pictures/towing_barless_transparent.png";
        }
        if (label.includes("6074")) {
          return "Pictures/Champ70_transparent.png";
        }
        if (name.includes("towing") || name.includes("tow") || name.includes("??????")) {
          return "Pictures/TowBar.png";
        }
        if (name.includes("loader") || name.includes("??????")) {
          return "Pictures/Loader.png";
        }
        if (name.includes("acu") || name.includes("a/c")) {
          return "Pictures/TLD ACU.png";
        }
        if (name.includes("gpu")) {
          return "Pictures/TLD GPU.png";
        }
        if (name.includes("stair") || name.includes("stairs")) {
          return "Pictures/staires.png";
        }
        if (name.includes("manito")) {
          return "Pictures/Manito.png";
        }
        if (name.includes("tractor") || name.includes("tracktor") || name.includes("trac")) {
          return "Pictures/Tracktor.png";
        }
        return "Pictures/Aviation1.jpg";
      }

      function markerSizeForZoom(zoom) {
        const safeZoom = Number.isFinite(zoom) ? zoom : 13;
        const size = 14 + (safeZoom - 10) * 3;
        return Math.max(20, Math.min(56, Math.round(size)));
      }

      function markerIcon(path, size) {
        const key = `${path}|${size}`;
        if (!iconCache.has(key)) {
          iconCache.set(
            key,
            L.icon({
              iconUrl: encodeURI(path),
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2],
              popupAnchor: [0, -size / 2],
            })
          );
        }
        return iconCache.get(key);
      }

      function updateMarkerIcons() {
        const size = markerSizeForZoom(map.getZoom());
        Object.values(markers).forEach((marker) => {
          const iconPath = marker.options.iconPath || "Pictures/Aviation1.jpg";
          marker.setIcon(markerIcon(iconPath, size));
        });
      }

      map.on("zoomend", updateMarkerIcons);

      const LOW_FUEL_THRESHOLD = 20;
      const LOW_BATTERY_THRESHOLD = 24;
      const MOVE_DISTANCE_METERS = 10;

      function parseNumber(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const num = Number(String(value).replace(/[^\d.-]/g, ""));
        return Number.isFinite(num) ? num : null;
      }

      function parseBoolean(value) {
        if (value === null || value === undefined) {
          return false;
        }
        if (typeof value === "boolean") {
          return value;
        }
        const text = String(value).trim().toLowerCase();
        return text === "on" || text === "true" || text === "1" || text === "yes" || text === "active";
      }

      function distanceMeters(lat1, lon1, lat2, lon2) {
        const toRad = (deg) => (deg * Math.PI) / 180;
        const r = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return r * c;
      }

      function updateDistance(id, lat, lng) {
        const prev = lastPositions.get(id);
        lastPositions.set(id, { lat, lng });
        if (!prev) {
          return 0;
        }
        return distanceMeters(prev.lat, prev.lng, lat, lng);
      }

      function isMoving(row) {
        const status = String(row.movement_status || "").toLowerCase();
        if (status.includes("moving")) {
          return true;
        }
        const speed = parseNumber(row.speed ?? row.Speed);
        return speed !== null ? speed > 0.5 : false;
      }

      function isIgnitionOn(row) {
        const ignition =
          row.Ignition ??
          row.ignition ??
          row["Ignition"] ??
          row["Ignition status"] ??
          row["ignition_status"] ??
          row.input1 ??
          row["input1"] ??
          row["Input1"] ??
          row["Input 1"];
        if (parseBoolean(ignition)) {
          return true;
        }
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        return rpm !== null ? rpm > 0 : false;
      }

      function isLoader(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        return label.includes("loader") || group.includes("loader") || label.includes("6074");
      }

      function isWorking(row, moving) {
        if (moving) {
          return false;
        }
        if (isIgnitionOn(row)) {
          return true;
        }
        const workingFlag =
          parseBoolean(row.Working) ||
          parseBoolean(row.working) ||
          parseBoolean(row["Working-Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer Extract"]) ||
          parseBoolean(row["Stabilizer_Extract"]);
        const oilPressure = parseNumber(row["Engine_O.P"] ?? row.Engine_O_P ?? row.Engine_OP);
        if (workingFlag) {
          return true;
        }
        if (isLoader(row) && oilPressure !== null) {
          return oilPressure > 2;
        }
        return false;
      }

      function isAlert(row) {
        const fuel = parseNumber(row.Fuel_level ?? row.Fuel ?? row["Fuel level"]);
        const battery = parseNumber(
          row["Battery level"] ??
            row.battery_level ??
            row.Voltage ??
            row.voltage ??
            row["Board voltage"]
        );
        const lowFuel = fuel !== null ? fuel < LOW_FUEL_THRESHOLD : false;
        const lowBattery = battery !== null ? battery < LOW_BATTERY_THRESHOLD : false;
        const nextService = parseNumber(row.next_service_hours ?? row["Next Service"]);
        const alertFlag =
          parseBoolean(row.Alert) ||
          parseBoolean(row.alert) ||
          parseBoolean(row["Repair requested"]);
        const nextServiceDue = nextService !== null ? nextService <= 0 : false;
        return lowFuel || nextServiceDue || alertFlag || lowBattery;
      }

      function statusLabel(row) {
        return row.movement_status || row.connection_status || "unknown";
      }

      function statusClass(row, moving, distanceMetersValue) {
        const rpm = parseNumber(row.engine_rpm ?? row["OBD: RPM"]);
        const maintenance =
          parseBoolean(row["Maintenance zone"]) ||
          parseBoolean(row.maintenance_zone) ||
          parseBoolean(row["In maintenance"]);
        const navixyStatus = String(row.movement_status || row.connection_status || "")
          .toLowerCase()
          .trim();

        if (isAlert(row)) {
          return "gse-status-alert";
        }
        if (maintenance) {
          return "gse-status-maintenance";
        }
        if (parseNumber(row.Voltage ?? row.voltage) !== null) {
          const voltage = parseNumber(row.Voltage ?? row.voltage);
          if (voltage !== null && voltage < LOW_BATTERY_THRESHOLD) {
            return "gse-status-low-battery";
          }
        }
        if (isWorking(row, moving)) {
          return "gse-status-working";
        }
        if (navixyStatus.includes("moving")) {
          return "gse-status-moving";
        }
        if (navixyStatus.includes("idle")) {
          return "gse-status-idle";
        }
        if (
          navixyStatus.includes("standstill") ||
          navixyStatus.includes("park") ||
          navixyStatus.includes("stopp")
        ) {
          return "gse-status-available";
        }
        if (navixyStatus.includes("offline")) {
          return "gse-status-stop";
        }
        if (moving || distanceMetersValue > MOVE_DISTANCE_METERS) {
          return "gse-status-moving";
        }
        if (rpm !== null && rpm !== 0) {
          return "gse-status-in-use";
        }
        if (rpm !== null && rpm < 2000 && distanceMetersValue <= MOVE_DISTANCE_METERS) {
          return "gse-status-idle";
        }
        if (isIgnitionOn(row)) {
          return "gse-status-ignition";
        }
        return "gse-status-available";
      }

      function updateTooltip(marker, text, className) {
        if (!marker.getTooltip()) {
          marker.bindTooltip(text, {
            permanent: true,
            direction: "top",
            offset: [0, -12],
            className: `gse-label ${className}`,
          });
          return;
        }
        marker.setTooltipContent(text);
        marker.getTooltip().options.className = `gse-label ${className}`;
        if (marker.getTooltip()._container) {
          marker.getTooltip()._container.className = `leaflet-tooltip gse-label ${className}`;
        }
      }

      function formatLabel(row) {
        const label = row.label || row.tracker_id || "";
        const match = String(label).match(/(\d{4})/);
        return match ? match[1] : String(label);
      }

      function formatStatus(row) {
        return row.movement_status || row.connection_status || "--";
      }

      function formatSensor(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("Fuel", row.Fuel_level ?? row.Fuel);
        add("Voltage", row["Board voltage"] ?? row.Voltage ?? row.voltage);
        add("EngTemp", row.Engine_Temp ?? row.engine_temperature);
        add("EngOP", row["Engine_O.P"]);
        add("RPM", row.engine_rpm);
        return parts.length ? parts.join(" | ") : "--";
      }

      function formatBeacon(row) {
        const parts = [];
        const add = (name, value) => {
          if (value !== null && value !== undefined && value !== "") {
            parts.push(`${name}:${value}`);
          }
        };
        add("BLE", row["BLE: ID"]);
        add("EyeBecon", row.EyeBecon);
        add("Key", row["Hardware key"]);
        return parts.length ? parts.join(" | ") : "--";
      }

      function renderTable(rows) {
        const head = document.getElementById("gseTableHead");
        const body = document.getElementById("gseTableBody");
        if (!head || !body) {
          return;
        }
        const headers = DASHBOARD_HEADERS.flatMap((h) => (h === "label" ? ["label", "label_updated"] : [h]));
        head.innerHTML = `<tr>${headers.map((h) => `<th>${h}</th>`).join("")}</tr>`;
        body.innerHTML = rows
          .map((row) => {
            const cells = headers.map((h) => {
              if (h === "label") {
                return formatLabel(row);
              }
              if (h === "label_updated") {
                return row.last_update || row.gps_updated || "--";
              }
              if (h.endsWith("__updated")) {
                return row[h] ?? "--";
              }
              return row[h] ?? "--";
            })
              .map((value) => `<td>${value}</td>`)
              .join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");
      }

      function popupHtml(row) {
        const label = row.label || row.tracker_id || "tracker";
        const lat = row.lat;
        const lng = row.lng;
        const status = statusLabel(row);
        const base = `<strong>${label}</strong><br/>${status}<br/>${lat}, ${lng}`;
        const extra = [];
        const sensorUpdated = (() => {
          const candidates = Object.keys(row || {})
            .filter((key) => key.endsWith("__updated"))
            .map((key) => row[key])
            .filter(Boolean);
          let latestRaw = null;
          let latestTime = null;
          candidates.forEach((value) => {
            const parsed = Date.parse(value);
            if (Number.isNaN(parsed)) {
              if (!latestRaw) {
                latestRaw = value;
              }
              return;
            }
            if (latestTime === null || parsed > latestTime) {
              latestTime = parsed;
              latestRaw = value;
            }
          });
          return latestRaw;
        })();
        const ignition = isIgnitionOn(row) ? "on" : "off";
        const ignitionUpdated = row["Ignition__updated"] ?? row["ignition__updated"];
        extra.push(`Ignition: ${ignition}${ignitionUpdated ? ` (updated ${ignitionUpdated})` : ""}`);
        const statusUpdated = row.last_update || row.gps_updated;
        if (statusUpdated) {
          extra.push(`Last status report: ${statusUpdated}`);
        }
        if (sensorUpdated) {
          extra.push(`Last sensor report: ${sensorUpdated}`);
        }
        if (label.includes("6074")) {
          const tempUpdated = row["Engine_Temp__updated"];
          const opUpdated = row["Engine_O.P__updated"];
          const fuelUpdated = row["Fuel__updated"];
          extra.push(
            `Engine_Temp: ${row.Engine_Temp ?? "--"}${tempUpdated ? ` (updated ${tempUpdated})` : ""}`
          );
          extra.push(
            `Engine_O.P: ${row["Engine_O.P"] ?? "--"}${opUpdated ? ` (updated ${opUpdated})` : ""}`
          );
          extra.push(`Fuel: ${row.Fuel ?? "--"}${fuelUpdated ? ` (updated ${fuelUpdated})` : ""}`);
          extra.push(`Engine Hours: ${row.engine_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        if (label.includes("5032")) {
          const fuelLevelUpdated = row["Fuel_level__updated"];
          const rpmUpdated = row["engine_rpm__updated"];
          extra.push(
            `Fuel_level: ${row.Fuel_level ?? "--"}${fuelLevelUpdated ? ` (updated ${fuelLevelUpdated})` : ""}`
          );
          extra.push(
            `Engine RPM: ${row.engine_rpm ?? "--"}${rpmUpdated ? ` (updated ${rpmUpdated})` : ""}`
          );
          extra.push(`Engine Hours: ${row.engine_hours_total ?? row.engine_hours ?? "--"}`);
          extra.push(`Next Service: ${row.next_service_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        return `${base}${extra.length ? "<br/>" + extra.join("<br/>") : ""}`;
      }

      function updateMarkers(rows) {
        isRefreshing = true;
        if (!map.hasLayer(layer)) {
          layer.addTo(map);
        }
        const bounds = [];
        const seen = new Set();
        rows.forEach((row) => {
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            return;
          }
          const label = row.label || row.tracker_id || "tracker";
          const shortMatch = String(label).match(/(\d{4})/);
          const shortLabel = shortMatch ? shortMatch[1] : label;
          const id = String(row.tracker_id || label);
          const iconPath = iconPathForRow(row);
          const size = markerSizeForZoom(map.getZoom());
          const distanceMetersValue = updateDistance(id, lat, lng);
          const moving = isMoving(row) || distanceMetersValue > MOVE_DISTANCE_METERS;
          const labelClass = statusClass(row, moving, distanceMetersValue);
          let marker = markers[id];
          if (!marker) {
            marker = L.marker([lat, lng], {
              icon: markerIcon(iconPath, size),
              iconPath,
            })
              .bindPopup(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
            marker.off("click", marker._openPopup);
            marker.on("click", () => {
              marker.openPopup();
              activePopupId = id;
            });
            marker.on("popupclose", () => {
              if (isRefreshing) {
                return;
              }
              if (activePopupId === id) {
                activePopupId = null;
              }
            });
            markers[id] = marker;
            marker.addTo(layer);
          } else {
            marker.setLatLng([lat, lng]);
            marker.setIcon(markerIcon(iconPath, size));
            marker.options.iconPath = iconPath;
            marker.setPopupContent(popupHtml(row));
            updateTooltip(marker, shortLabel, labelClass);
          }
          seen.add(id);
          if (!String(label).toLowerCase().includes("skoda")) {
            bounds.push([lat, lng]);
          }
        });
        Object.keys(markers).forEach((key) => {
          if (!seen.has(key)) {
            const marker = markers[key];
            layer.removeLayer(marker);
            delete markers[key];
            if (activePopupId === key) {
              activePopupId = null;
            }
          }
        });

        const statusEl = document.getElementById("mapStatus");
        const debugEl = document.getElementById("mapDebug");
        if (statusEl) {
          statusEl.textContent = `Trackers: ${rows.length} | Markers: ${bounds.length}`;
        }
        if (debugEl) {
          const first = rows.find((row) => Number.isFinite(Number(row.lat)) && Number.isFinite(Number(row.lng)));
          const zoom = map.getZoom();
          debugEl.textContent = first
            ? `| zoom ${zoom} | ${Number(first.lat).toFixed(5)}, ${Number(first.lng).toFixed(5)}`
            : `| zoom ${zoom} | no lat/lng`;
        }

        if (!fitted) {
          if (bounds.length === 1) {
            map.setView(bounds[0], 15);
          } else {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          fitted = true;
        }
        if (activePopupId && markers[activePopupId]) {
          markers[activePopupId].openPopup();
        }
        isRefreshing = false;
      }

      async function loadData() {
        try {
          const response = await fetch(LIVE_API_URL);
          if (!response.ok) {
            throw new Error("fetch failed");
          }
          const payload = await response.json();
          lastRows = payload.rows || [];
          updateMarkers(lastRows);
          renderTable(lastRows);
        } catch (error) {
          const statusEl = document.getElementById("mapStatus");
          if (statusEl) {
            statusEl.textContent = "Failed to load live data.";
          }
        }
      }

      loadData();
      setInterval(loadData, POLL_INTERVAL_MS);

      fetch("llbg_layers.geojson")
        .then((res) => res.json())
        .then((data) => {
          L.geoJSON(data, {
            pointToLayer: (feature, latlng) =>
              L.circleMarker(latlng, {
                radius: 7,
                color: "#7c3aed",
                fillColor: "#a855f7",
                fillOpacity: 0.9,
                weight: 2,
              }),
            onEachFeature: (feature, layer) => {
              const name = feature.properties?.name || "LLBG point";
              const source = feature.properties?.source || "";
              layer.bindTooltip(`${name}`, {
                direction: "top",
                permanent: true,
                opacity: 0.9,
                className: "llbg-label",
              });
              layer.bindPopup(`${name}<br/>${source}`);
            },
          }).addTo(llbgLayer);
        })
        .catch(() => {});

      // Removed LLBG chart overlays from the layer list.
    </script>
  </body>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Navixy Live Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .map-overlay {
        position: absolute;
        top: 12px;
        left: 12px;
        background: rgba(17, 24, 39, 0.85);
        color: #ffffff;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 12px;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="map-overlay" id="mapStatus">Loading...</div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const LIVE_API_URL = "https://outside-notebook-sheer-discounted.trycloudflare.com/data";
      const POLL_INTERVAL_MS = 2000;
      const map = L.map("map").setView([32.004, 34.876], 13);
      const layer = L.layerGroup().addTo(map);

      const osmStreets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      const osmStandard = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors",
      });
      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri",
        }
      );
      L.control
        .layers(
          {
            "OSM streets": osmStreets,
            OSM: osmStandard,
            "Satellite (Esri)": esriSat,
          },
          {},
          { position: "topright" }
        )
        .addTo(map);

      const markers = {};
      let fitted = false;
      const iconCache = new Map();

      function iconPathForRow(row) {
        const label = String(row.label || "").toLowerCase();
        const group = String(row.group_name || "").toLowerCase();
        const name = `${label} ${group}`;
        if (label.includes("5032")) {
          return "Pictures/towing_barless_transparent.png";
        }
        if (label.includes("6074")) {
          return "Pictures/Champ70_transparent.png";
        }
        if (name.includes("towing") || name.includes("tow") || name.includes("????????????")) {
          return "Pictures/TowBar.png";
        }
        if (name.includes("loader") || name.includes("????????????")) {
          return "Pictures/Loader.png";
        }
        if (name.includes("acu") || name.includes("a/c")) {
          return "Pictures/TLD ACU.png";
        }
        if (name.includes("gpu")) {
          return "Pictures/TLD GPU.png";
        }
        if (name.includes("stair") || name.includes("stairs")) {
          return "Pictures/staires.png";
        }
        if (name.includes("manito")) {
          return "Pictures/Manito.png";
        }
        if (name.includes("tractor") || name.includes("tracktor") || name.includes("trac")) {
          return "Pictures/Tracktor.png";
        }
        return "Pictures/Aviation1.jpg";
      }

      function markerSizeForZoom(zoom) {
        const size = 14 + (zoom - 10) * 3;
        return Math.max(20, Math.min(56, Math.round(size)));
      }

      function markerIcon(path, size) {
        const key = `${path}|${size}`;
        if (!iconCache.has(key)) {
          iconCache.set(
            key,
            L.icon({
              iconUrl: encodeURI(path),
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2],
              popupAnchor: [0, -size / 2],
            })
          );
        }
        return iconCache.get(key);
      }

      function updateMarkerIcons() {
        const size = markerSizeForZoom(map.getZoom());
        Object.values(markers).forEach((marker) => {
          const iconPath = marker.options.iconPath || "Pictures/Aviation1.jpg";
          marker.setIcon(markerIcon(iconPath, size));
        });
      }

      map.on("zoomend", updateMarkerIcons);

      function statusLabel(row) {
        return row.movement_status || row.connection_status || "unknown";
      }

      function popupHtml(row) {
        const label = row.label || row.tracker_id || "tracker";
        const lat = row.lat;
        const lng = row.lng;
        const status = statusLabel(row);
        const base = `<strong>${label}</strong><br/>${status}<br/>${lat}, ${lng}`;
        const extra = [];
        if (label.includes("6074")) {
          extra.push(`Engine_Temp: ${row.Engine_Temp ?? "--"}`);
          extra.push(`Engine_O.P: ${row["Engine_O.P"] ?? "--"}`);
          extra.push(`Fuel: ${row.Fuel ?? "--"}`);
          extra.push(`Engine Hours: ${row.engine_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        if (label.includes("5032")) {
          extra.push(`Fuel_level: ${row.Fuel_level ?? "--"}`);
          extra.push(`Engine RPM: ${row.engine_rpm ?? "--"}`);
          extra.push(`Engine Hours: ${row.engine_hours_total ?? row.engine_hours ?? "--"}`);
          extra.push(`Next Service: ${row.next_service_hours ?? "--"}`);
          extra.push(`Odometer: ${row.odometer ?? "--"}`);
        }
        return `${base}${extra.length ? "<br/>" + extra.join("<br/>") : ""}`;
      }

      function updateMarkers(rows) {
        layer.clearLayers();
        const bounds = [];
        Object.keys(markers).forEach((key) => delete markers[key]);
        rows.forEach((row) => {
          const lat = Number(row.lat);
          const lng = Number(row.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            return;
          }
          const status = row.connection_status || "unknown";
          const label = row.label || row.tracker_id || "tracker";
          const iconPath = iconPathForRow(row);
          const size = markerSizeForZoom(map.getZoom());
          const marker = L.marker([lat, lng], {
            icon: markerIcon(iconPath, size),
            iconPath,
          })
            .bindPopup(popupHtml(row))
            .bindTooltip(label, { permanent: true, direction: "top", offset: [0, -12] });
          markers[label] = marker;
          marker.addTo(layer);
          if (!String(label).toLowerCase().includes("skoda")) {
            bounds.push([lat, lng]);
          }
        });

        const statusEl = document.getElementById("mapStatus");
        if (statusEl) {
          statusEl.textContent = `Trackers: ${rows.length} | Markers: ${bounds.length}`;
        }

        if (!fitted) {
          if (bounds.length === 1) {
            map.setView(bounds[0], 15);
          } else {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          fitted = true;
        }
      }

      async function loadData() {
        try {
          const response = await fetch(LIVE_API_URL);
          if (!response.ok) {
            throw new Error("fetch failed");
          }
          const payload = await response.json();
          updateMarkers(payload.rows || []);
        } catch (error) {
          const statusEl = document.getElementById("mapStatus");
          if (statusEl) {
            statusEl.textContent = "Failed to load live data.";
          }
        }
      }

      loadData();
      setInterval(loadData, POLL_INTERVAL_MS);
    </script>
  </body>
</html>
